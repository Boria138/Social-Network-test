// API helper
function getApiUrl() {
    return window.APP_CONFIG?.API_URL || '';
}

// Global state
let currentChannel = null;
let channels = {};
let inCall = false;
let localStream = null;
let screenStream = null;
let peerConnections = {};
let isVideoEnabled = true;
let isAudioEnabled = true;
let isMuted = false;
let isDeafened = false;
let currentUser = null;
let socket = null;
let token = null;
let currentView = 'friends';
let currentDMUserId = null;
// Initialize
document.addEventListener('DOMContentLoaded', () => {
    token = localStorage.getItem('token');
    const userStr = localStorage.getItem('currentUser');
    
    if (!token || !userStr) {
        window.location.replace('login.html');
        return;
    }
    
    try {
        currentUser = JSON.parse(userStr);
        initializeApp();
    } catch (e) {
        console.error('Error parsing user data:', e);
        localStorage.removeItem('token');
        localStorage.removeItem('currentUser');
        window.location.replace('login.html');
    }
});

function initializeApp() {
    updateUserInfo();
    initializeFriendsTabs();
    initializeMessageInput();
    initializeUserControls();
    initializeCallControls();
    initializeFileUpload();
    initializeEmojiPicker();
    initializeDraggableCallWindow();
    connectToSocketIO();
    // requestNotificationPermission(); // Ğ£Ğ±Ñ€Ğ°Ğ½Ğ¾ Ğ¸Ğ· Ğ°Ğ²Ñ‚Ğ¾Ğ·Ğ°Ğ¿ÑƒÑĞºĞ°
    showFriendsView();

    // ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº ĞºĞ»Ğ¸ĞºĞ° Ğ½Ğ° ĞºĞ½Ğ¾Ğ¿ĞºÑƒ Friends Ğ´Ğ»Ñ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚Ğ° Ğ½Ğ° Ğ³Ğ»Ğ°Ğ²Ğ½ÑƒÑ ÑÑ‚Ñ€Ğ°Ğ½Ğ¸Ñ†Ñƒ
    const friendsBtn = document.getElementById('friendsBtn');
    if (friendsBtn) {
        friendsBtn.addEventListener('click', () => {
            showFriendsView();
        });
    }

    // Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº Ğ´Ğ»Ñ Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑĞ° Ñ€Ğ°Ğ·Ñ€ĞµÑˆĞµĞ½Ğ¸Ñ Ğ¿Ñ€Ğ¸ Ğ¿ĞµÑ€Ğ²Ğ¾Ğ¼ Ğ²Ğ·Ğ°Ğ¸Ğ¼Ğ¾Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğ¸ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
    document.addEventListener('click', requestNotificationPermissionOnce, { once: true });
    document.addEventListener('keydown', requestNotificationPermissionOnce, { once: true });

    // Setup reply to selection functionality
    setupReplyToSelection();
}

function requestNotificationPermissionOnce() {
    if ('Notification' in window && Notification.permission === 'default') {
        Notification.requestPermission();
    }
}

function requestNotificationPermission() {
    if ('Notification' in window && Notification.permission === 'default') {
        Notification.requestPermission();
    }
}

function showNotification(title, body) {
    if ('Notification' in window && Notification.permission === 'granted') {
        new Notification(title, { body });
    }
}

function updateUserInfo() {
    const userAvatar = document.querySelector('.user-avatar');
    const username = document.querySelector('.username');
    
    if (userAvatar) userAvatar.textContent = currentUser.avatar;
    if (username) username.textContent = currentUser.username;
}

function connectToSocketIO() {
    if (typeof io !== 'undefined') {
        const apiUrl = getApiUrl();
        const socketOpts = {
            auth: { token: token },
            ...(window.APP_CONFIG?.SOCKET_OPTIONS || {})
        };
        socket = apiUrl ? io(apiUrl, socketOpts) : io(socketOpts);
        
        socket.on('connect', () => {
            console.log('Connected to server');
        });
        
       socket.on('connect_error', (error) => {
            console.error('Connection error:', error);
        });
        
        
        socket.on('reaction-update', (data) => {
            updateMessageReactions(data.messageId, data.reactions);
        });

        // WebRTC Signaling
        socket.on('new-dm', (data) => {
            // ĞÑ‚Ğ¾Ğ±Ñ€Ğ°Ğ¶Ğ°ĞµĞ¼ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ, ĞµÑĞ»Ğ¸ Ğ¾Ğ½Ğ¾ Ğ¾Ñ‚ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ, Ñ ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğ¼ Ğ¼Ñ‹ Ğ¾Ğ±Ñ‰Ğ°ĞµĞ¼ÑÑ
            if (currentView === 'dm' && currentDMUserId && data.senderId === currentDMUserId) {
                addMessageToUI({
                    id: data.message.id,
                    author: data.message.author,
                    avatar: data.message.avatar,
                    text: data.message.text,
                    timestamp: data.message.timestamp,
                    reactions: data.message.reactions || [],
                    file: data.message.file  // Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾ Ñ„Ğ°Ğ¹Ğ»Ğµ, ĞµÑĞ»Ğ¸ Ğ¾Ğ½Ğ° ĞµÑÑ‚ÑŒ
                });
                scrollToBottom();
            }
        });

        socket.on('dm-sent', (data) => {
            // ĞÑ‚Ğ¾Ğ±Ñ€Ğ°Ğ¶Ğ°ĞµĞ¼ Ğ½Ğ°ÑˆĞµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ, ĞµÑĞ»Ğ¸ Ğ¾Ğ½Ğ¾ Ğ±Ñ‹Ğ»Ğ¾ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¾ Ğ² Ñ‚ĞµĞºÑƒÑ‰Ğ¸Ğ¹ Ñ‡Ğ°Ñ‚
            if (currentView === 'dm' && currentDMUserId && data.receiverId === currentDMUserId) {
                // Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ, ĞºĞ¾Ñ‚Ğ¾Ñ€Ğ¾Ğµ Ğ¼Ñ‹ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»Ğ¸
                addMessageToUI({
                    id: data.message.id,
                    author: currentUser.username,
                    avatar: currentUser.avatar,
                    text: data.message.text,
                    timestamp: data.message.timestamp,
                    reactions: data.message.reactions || [],
                    file: data.message.file  // Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾ Ñ„Ğ°Ğ¹Ğ»Ğµ, ĞµÑĞ»Ğ¸ Ğ¾Ğ½Ğ° ĞµÑÑ‚ÑŒ
                });
                scrollToBottom();
            }
        });

        socket.on('new-friend-request', () => {
            loadPendingRequests();
            showNotification('New Friend Request', 'You have a new friend request!');
        });

        socket.on('incoming-call', (data) => {
            const { from, type } = data;
            if (from) {
                showIncomingCall(from, type);
            }
        });

        socket.on('call-accepted', (data) => {
            console.log('Call accepted by:', data.from);
            // When call is accepted, create peer connection
            document.querySelector('.call-channel-name').textContent = `Connected with ${data.from.username}`;
            
            // Create peer connection as initiator
            if (!peerConnections[data.from.socketId]) {
                createPeerConnection(data.from.socketId, true);
            }
        });

        socket.on('call-rejected', (data) => {
            alert('Call was declined');
            // Close call interface
            const callInterface = document.getElementById('callInterface');
            callInterface.classList.add('hidden');
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            inCall = false;
        });
        
        socket.on('call-ended', (data) => {
            // Handle when other party ends the call
            if (peerConnections[data.from]) {
                peerConnections[data.from].close();
                delete peerConnections[data.from];
            }
            const remoteVideo = document.getElementById(`remote-${data.from}`);
            if (remoteVideo) remoteVideo.remove();
            
            // If no more connections, end the call
            if (Object.keys(peerConnections).length === 0) {
                leaveVoiceChannel(true);
            }
        });
    }
}

// Initialize friends tabs
function initializeFriendsTabs() {
    const tabs = document.querySelectorAll('.friends-tab');
    tabs.forEach(tab => {
        tab.addEventListener('click', () => {
            const tabName = tab.getAttribute('data-tab');
            switchFriendsTab(tabName);
        });
    });

    const searchBtn = document.getElementById('searchUserBtn');
    if (searchBtn) {
        searchBtn.addEventListener('click', searchUsers);
    }

    loadFriends();
}

function switchFriendsTab(tabName) {
    document.querySelectorAll('.friends-tab').forEach(t => t.classList.remove('active'));
    document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
    
    document.querySelectorAll('.friends-list').forEach(l => l.classList.remove('active-tab'));
    const contentMap = {
        'online': 'friendsOnline',
        'all': 'friendsAll',
        'pending': 'friendsPending',
        'add': 'friendsAdd'
    };
    document.getElementById(contentMap[tabName]).classList.add('active-tab');
    
    if (tabName === 'pending') {
        loadPendingRequests();
    }
}

async function loadFriends() {
    try {
        const response = await fetch(`${getApiUrl()}/api/friends`, {
            headers: { 'Authorization': `Bearer ${token}` }
        });
        const friends = await response.json();
        displayFriends(friends);
        populateDMList(friends);
    } catch (error) {
        console.error('Error loading friends:', error);
    }
}

function displayFriends(friends) {
    const onlineList = document.getElementById('friendsOnline');
    const allList = document.getElementById('friendsAll');
    
    onlineList.innerHTML = '';
    allList.innerHTML = '';
    
    if (friends.length === 0) {
        onlineList.innerHTML = '<div class="friends-empty">No friends yet</div>';
        allList.innerHTML = '<div class="friends-empty">No friends yet</div>';
        return;
    }
    
    const onlineFriends = friends.filter(f => f.status === 'Online');
    
    if (onlineFriends.length === 0) {
        onlineList.innerHTML = '<div class="friends-empty">No one is online</div>';
    } else {
        onlineFriends.forEach(friend => {
            onlineList.appendChild(createFriendItem(friend));
        });
    }
    
    friends.forEach(friend => {
        allList.appendChild(createFriendItem(friend));
    });
}

function createFriendItem(friend) {
    const div = document.createElement('div');
    div.className = 'friend-item';
    
    div.innerHTML = `
        <div class="friend-avatar">${friend.avatar || friend.username.charAt(0).toUpperCase()}</div>
        <div class="friend-info">
            <div class="friend-name">${friend.username}</div>
            <div class="friend-status ${friend.status === 'Online' ? '' : 'offline'}">${friend.status}</div>
        </div>
        <div class="friend-actions">
            <button class="friend-action-btn message" title="Message">ğŸ’¬</button>
            <button class="friend-action-btn audio-call" title="Audio Call">ğŸ“</button>
            <button class="friend-action-btn video-call" title="Video Call">ğŸ“¹</button>
            <button class="friend-action-btn remove" title="Remove">ğŸ—‘ï¸</button>
        </div>
    `;

    div.querySelector('.message').addEventListener('click', () => startDM(friend.id, friend.username));
    div.querySelector('.audio-call').addEventListener('click', () => initiateCall(friend.id, 'audio'));
    div.querySelector('.video-call').addEventListener('click', () => initiateCall(friend.id, 'video'));
    div.querySelector('.remove').addEventListener('click', () => removeFriend(friend.id));
    
    return div;
}

async function searchUsers() {
    const searchInput = document.getElementById('searchUserInput');
    const query = searchInput.value.trim();
    
    if (!query) return;
    
    try {
        const response = await fetch(`${getApiUrl()}/api/users`, {
            headers: { 'Authorization': `Bearer ${token}` }
        });
        const users = await response.json();
        
        const results = users.filter(u => 
            u.username.toLowerCase().includes(query.toLowerCase()) && 
            u.id !== currentUser.id
        );
        
        displaySearchResults(results);
    } catch (error) {
        console.error('Error searching users:', error);
    }
}

function displaySearchResults(users) {
    const resultsDiv = document.getElementById('searchResults');
    resultsDiv.innerHTML = '';
    
    if (users.length === 0) {
        resultsDiv.innerHTML = '<div class="friends-empty">No users found</div>';
        return;
    }
    
    users.forEach(user => {
        const div = document.createElement('div');
        div.className = 'user-search-item';
        
        div.innerHTML = `
            <div class="user-avatar">${user.avatar || user.username.charAt(0).toUpperCase()}</div>
            <div class="user-info">
                <div class="user-name">${user.username}</div>
            </div>
            <button class="add-friend-btn" onclick="sendFriendRequest(${user.id})">Add Friend</button>
        `;
        
        resultsDiv.appendChild(div);
    });
}

window.sendFriendRequest = async function(friendId) {
    try {
        const response = await fetch(`${getApiUrl()}/api/friends/request`, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${token}`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ friendId })
        });
        
        if (response.ok) {
            alert('Friend request sent!');
        } else {
            const error = await response.json();
            alert(error.error || 'Failed to send request');
        }
    } catch (error) {
        console.error('Error sending friend request:', error);
        alert('Failed to send friend request');
    }
};

async function loadPendingRequests() {
    try {
        const response = await fetch(`${getApiUrl()}/api/friends/pending`, {
            headers: { 'Authorization': `Bearer ${token}` }
        });
        const requests = await response.json();
        
        const pendingList = document.getElementById('friendsPending');
        pendingList.innerHTML = '';
        
        if (requests.length === 0) {
            pendingList.innerHTML = '<div class="friends-empty">No pending requests</div>';
            return;
        }
        
        requests.forEach(request => {
            const div = document.createElement('div');
            div.className = 'friend-item';
            
            div.innerHTML = `
                <div class="friend-avatar">${request.avatar || request.username.charAt(0).toUpperCase()}</div>
                <div class="friend-info">
                    <div class="friend-name">${request.username}</div>
                    <div class="friend-status">Incoming Friend Request</div>
                </div>
                <div class="friend-actions">
                    <button class="friend-action-btn accept" onclick="acceptFriendRequest(${request.id})">âœ“</button>
                    <button class="friend-action-btn reject" onclick="rejectFriendRequest(${request.id})">âœ•</button>
                </div>
            `;
            
            pendingList.appendChild(div);
        });
    } catch (error) {
        console.error('Error loading pending requests:', error);
    }
}

window.acceptFriendRequest = async function(friendId) {
    try {
        const response = await fetch(`${getApiUrl()}/api/friends/accept`, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${token}`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ friendId })
        });
        
        if (response.ok) {
            loadPendingRequests();
            loadFriends();
        }
    } catch (error) {
        console.error('Error accepting friend request:', error);
    }
};

window.rejectFriendRequest = async function(friendId) {
    try {
        const response = await fetch(`${getApiUrl()}/api/friends/reject`, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${token}`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ friendId })
        });
        
        if (response.ok) {
            loadPendingRequests();
        }
    } catch (error) {
        console.error('Error rejecting friend request:', error);
    }
};

window.removeFriend = async function(friendId) {
    if (!confirm('Are you sure you want to remove this friend?')) return;
    
    try {
        const response = await fetch(`/api/friends/${friendId}`, {
            method: 'DELETE',
            headers: { 'Authorization': `Bearer ${token}` }
        });
        
        if (response.ok) {
            loadFriends();
        }
    } catch (error) {
        console.error('Error removing friend:', error);
    }
};

// Initiate call function
async function initiateCall(friendId, type) {
    try {
        // Always request both video and audio, but disable video if it's audio call
        const constraints = { video: true, audio: true };
        
        localStream = await navigator.mediaDevices.getUserMedia(constraints);
        
        // If audio call, disable video track initially
        if (type === 'audio') {
            localStream.getVideoTracks().forEach(track => {
                track.enabled = false;
            });
        }
        
        // Show call interface
        const callInterface = document.getElementById('callInterface');
        callInterface.classList.remove('hidden');
        
        // Update call header
        document.querySelector('.call-channel-name').textContent = `Calling...`;
        
        // Set local video
        const localVideo = document.getElementById('localVideo');
        localVideo.srcObject = localStream;
        
        // Store call details
        window.currentCallDetails = {
            friendId: friendId,
            type: type,
            isInitiator: true,
            originalType: type
        };
        
        // Emit call request via socket
        if (socket && socket.connected) {
            socket.emit('initiate-call', {
                to: friendId,
                type: type,
                from: {
                    id: currentUser.id,
                    username: currentUser.username,
                    socketId: socket.id
                }
            });
        }
        
        inCall = true;
        isVideoEnabled = type === 'video';
        isAudioEnabled = true;
        updateCallButtons();
        
        // Initialize resizable functionality after a short delay
        setTimeout(() => {
            if (typeof initializeResizableVideos === 'function') {
                initializeResizableVideos();
            }
        }, 100);
        
    } catch (error) {
        console.error('Error initiating call:', error);
        alert('Failed to access camera/microphone. Please check permissions.');
    }
}

// Show incoming call notification
function showIncomingCall(caller, type) {
    const incomingCallDiv = document.getElementById('incomingCall');
    const callerName = incomingCallDiv.querySelector('.caller-name');
    const callerAvatar = incomingCallDiv.querySelector('.caller-avatar');
    
    callerName.textContent = caller.username || 'Unknown User';
    callerAvatar.textContent = caller.avatar || caller.username?.charAt(0).toUpperCase() || 'U';
    
    incomingCallDiv.classList.remove('hidden');
    
    // Set up accept/reject handlers
    const acceptBtn = document.getElementById('acceptCallBtn');
    const rejectBtn = document.getElementById('rejectCallBtn');
    
    acceptBtn.onclick = async () => {
        incomingCallDiv.classList.add('hidden');
        await acceptCall(caller, type);
    };
    
    rejectBtn.onclick = () => {
        incomingCallDiv.classList.add('hidden');
        rejectCall(caller);
    };
    
    // Auto-reject after 30 seconds
    setTimeout(() => {
        if (!incomingCallDiv.classList.contains('hidden')) {
            incomingCallDiv.classList.add('hidden');
            rejectCall(caller);
        }
    }, 30000);
}

// Accept incoming call
async function acceptCall(caller, type) {
    try {
        // Always request both video and audio
        const constraints = { video: true, audio: true };
        
        localStream = await navigator.mediaDevices.getUserMedia(constraints);
        
        // If audio call, disable video track initially
        if (type === 'audio') {
            localStream.getVideoTracks().forEach(track => {
                track.enabled = false;
            });
        }
        
        // Show call interface
        const callInterface = document.getElementById('callInterface');
        callInterface.classList.remove('hidden');
        
        document.querySelector('.call-channel-name').textContent = `Call with ${caller.username}`;
        
        const localVideo = document.getElementById('localVideo');
        localVideo.srcObject = localStream;
        
        // Store call details
        window.currentCallDetails = {
            peerId: caller.socketId,
            type: type,
            isInitiator: false,
            originalType: type
        };
        
        if (socket && socket.connected) {
            socket.emit('accept-call', {
                to: caller.socketId,
                from: {
                    id: currentUser.id,
                    username: currentUser.username,
                    socketId: socket.id
                }
            });
        }
        
        inCall = true;
        isVideoEnabled = type === 'video';
        isAudioEnabled = true;
        updateCallButtons();
        
        // Create peer connection as receiver (not initiator)
        if (!peerConnections[caller.socketId]) {
            createPeerConnection(caller.socketId, false);
        }
        
        // Initialize resizable functionality after a short delay
        setTimeout(() => {
            if (typeof initializeResizableVideos === 'function') {
                initializeResizableVideos();
            }
        }, 100);
        
    } catch (error) {
        console.error('Error accepting call:', error);
        alert('Failed to access camera/microphone. Please check permissions.');
    }
}

// Reject incoming call
function rejectCall(caller) {
    if (socket && socket.connected) {
        socket.emit('reject-call', { to: caller.socketId });
    }
}

window.startDM = async function(friendId, friendUsername) {
    currentView = 'dm';
    currentDMUserId = friendId;
    // currentServerId = null; // Ğ£Ğ±Ñ€Ğ°Ğ½Ğ¾, Ñ‚Ğ°Ğº ĞºĞ°Ğº ÑĞµÑ€Ğ²ĞµÑ€Ñ‹ Ğ±Ğ¾Ğ»ÑŒÑˆĞµ Ğ½Ğµ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒÑÑ‚ÑÑ

    const friendsView = document.getElementById('friendsView');
    const chatView = document.getElementById('chatView');
    const dmListView = document.getElementById('dmListView');

    if (friendsView) friendsView.style.display = 'none';
    if (chatView) chatView.style.display = 'flex';
    // document.getElementById('channelsView').style.display = 'none'; // Ğ£Ğ±Ñ€Ğ°Ğ½Ğ¾, Ñ‚Ğ°Ğº ĞºĞ°Ğº ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚ Ğ±Ğ¾Ğ»ÑŒÑˆĞµ Ğ½Ğµ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒĞµÑ‚
    if (dmListView) dmListView.style.display = 'block';

    const chatHeaderInfo = document.getElementById('chatHeaderInfo');
    if (chatHeaderInfo) {
        chatHeaderInfo.innerHTML = `
            <div class="friend-avatar">${friendUsername.charAt(0).toUpperCase()}</div>
            <span class="channel-name">${friendUsername}</span>
        `;
    }

    const messageInput = document.getElementById('messageInput');
    if (messageInput) {
        messageInput.placeholder = `Message @${friendUsername}`;
    }

    await loadDMHistory(friendId);
};

// Ğ¤ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ´Ğ»Ñ Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚Ğ¸Ñ Ñ‡Ğ°Ñ‚Ğ° Ñ ÑĞ°Ğ¼Ğ¸Ğ¼ ÑĞ¾Ğ±Ğ¾Ğ¹
function startSelfChat() {
    currentView = 'dm';
    currentDMUserId = currentUser.id; // Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ ID Ñ‚ĞµĞºÑƒÑ‰ĞµĞ³Ğ¾ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ

    const friendsView = document.getElementById('friendsView');
    const chatView = document.getElementById('chatView');
    const dmListView = document.getElementById('dmListView');

    if (friendsView) friendsView.style.display = 'none';
    if (chatView) chatView.style.display = 'flex';
    if (dmListView) dmListView.style.display = 'block';

    const chatHeaderInfo = document.getElementById('chatHeaderInfo');
    if (chatHeaderInfo) {
        chatHeaderInfo.innerHTML = `
            <div class="friend-avatar">${currentUser.avatar || currentUser.username.charAt(0).toUpperCase()}</div>
            <span class="channel-name">Self Chat</span>
        `;
    }

    const messageInput = document.getElementById('messageInput');
    if (messageInput) {
        messageInput.placeholder = `Message yourself...`;
    }

    // Ğ—Ğ°Ğ³Ñ€ÑƒĞ¶Ğ°ĞµĞ¼ Ğ¸ÑÑ‚Ğ¾Ñ€Ğ¸Ñ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğ¹ Ğ´Ğ»Ñ Self Chat
    loadSelfChatHistory();
}

// Ğ¤ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ´Ğ»Ñ Ğ·Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ¸ Ğ¸ÑÑ‚Ğ¾Ñ€Ğ¸Ğ¸ Self Chat Ğ¸Ğ· localStorage
function loadSelfChatHistory() {
    const messagesContainer = document.getElementById('messagesContainer');

    if (!messagesContainer) {
        console.error('Messages container element not found');
        return;
    }

    messagesContainer.innerHTML = '';

    // ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ¸ÑÑ‚Ğ¾Ñ€Ğ¸Ñ Ğ¸Ğ· localStorage
    const selfChatHistory = JSON.parse(localStorage.getItem(`selfChatHistory_${currentUser.id}`)) || [];

    selfChatHistory.forEach(message => {
        addMessageToUI({
            id: message.id,
            author: message.author,
            avatar: message.avatar,
            text: message.text,
            timestamp: message.timestamp,
            reactions: message.reactions || [],
            file: message.file  // Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾ Ñ„Ğ°Ğ¹Ğ»Ğµ, ĞµÑĞ»Ğ¸ Ğ¾Ğ½Ğ° ĞµÑÑ‚ÑŒ
        });
    });

    scrollToBottom();
}

// Ğ¤ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ´Ğ»Ñ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ñ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ Ğ² Ğ¸ÑÑ‚Ğ¾Ñ€Ğ¸Ğ¸ Self Chat
function saveSelfMessageToHistory(message) {
    const key = `selfChatHistory_${currentUser.id}`;
    const history = JSON.parse(localStorage.getItem(key)) || [];

    // Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ½Ğ¾Ğ²Ğ¾Ğµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ
    history.push(message);

    // Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ Ğ¾Ğ±Ñ€Ğ°Ñ‚Ğ½Ğ¾ Ğ² localStorage
    localStorage.setItem(key, JSON.stringify(history));
}

// Show friends view
function showFriendsView() {
    currentView = 'friends';
    currentDMUserId = null;

    const friendsView = document.getElementById('friendsView');
    const chatView = document.getElementById('chatView');
    const dmListView = document.getElementById('dmListView');
    const serverName = document.getElementById('serverName');
    const friendsBtn = document.getElementById('friendsBtn');

    if (friendsView) friendsView.style.display = 'flex';
    if (chatView) chatView.style.display = 'none';
    if (dmListView) dmListView.style.display = 'block';
    if (serverName) serverName.textContent = 'Friends';
    if (friendsBtn) friendsBtn.classList.add('active');

    // Hide chat and show friends content
    if (chatView) chatView.style.display = 'none';
    if (friendsView) friendsView.style.display = 'flex';
}

// Show server view



function initializeMessageInput() {
    const messageInput = document.getElementById('messageInput');

    if (!messageInput) {
        console.error('Message input element not found');
        return;
    }

    messageInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            sendMessage();
        }

        // ĞĞ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¾Ğµ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğµ Ğ²Ñ‹ÑĞ¾Ñ‚Ñ‹ Ğ¿Ñ€Ğ¸ Ğ²Ğ²Ğ¾Ğ´Ğµ Ñ‚ĞµĞºÑÑ‚Ğ°
        adjustTextareaHeight(messageInput);
    });

    // ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº Ğ´Ğ»Ñ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ Ğ²Ñ‹ÑĞ¾Ñ‚Ñ‹ Ğ¿Ñ€Ğ¸ Ğ²Ğ²Ğ¾Ğ´Ğµ Ñ‚ĞµĞºÑÑ‚Ğ°
    messageInput.addEventListener('input', (e) => {
        adjustTextareaHeight(messageInput);
    });
}

// Ğ¤ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ´Ğ»Ñ Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¾Ğ³Ğ¾ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ Ğ²Ñ‹ÑĞ¾Ñ‚Ñ‹ textarea
function adjustTextareaHeight(textarea) {
    textarea.style.height = 'auto';
    textarea.style.height = Math.min(textarea.scrollHeight, 150) + 'px';
}

function sendMessage() {
    const messageInput = document.getElementById('messageInput');

    if (!messageInput) {
        console.error('Message input element not found');
        return;
    }

    const text = messageInput.value.trim();

    if (text === '') return;

    const message = {
        id: Date.now(), // Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½ÑƒÑ Ğ¼ĞµÑ‚ĞºÑƒ ĞºĞ°Ğº ID
        text: text,
        author: currentUser.username,
        avatar: currentUser.avatar || currentUser.username.charAt(0).toUpperCase(),
        timestamp: new Date(),
        reactions: []
    };

    // Ğ•ÑĞ»Ğ¸ ÑÑ‚Ğ¾ Self Chat, ÑĞ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ»Ğ¾ĞºĞ°Ğ»ÑŒĞ½Ğ¾
    if (currentDMUserId === currentUser.id) {
        addMessageToUI(message);
        saveSelfMessageToHistory(message);
        scrollToBottom();
    } else if (currentDMUserId) {
        // Ğ”Ğ»Ñ Ğ¾Ğ±Ñ‹Ñ‡Ğ½Ñ‹Ñ… DM Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ Ñ‡ĞµÑ€ĞµĞ· ÑĞ¾ĞºĞµÑ‚
        if (socket && socket.connected) {
            socket.emit('send-dm', {
                receiverId: currentDMUserId,
                message: message
            });
        }
    }

    messageInput.value = '';
    // Ğ¡Ğ±Ñ€Ğ°ÑÑ‹Ğ²Ğ°ĞµĞ¼ Ğ²Ñ‹ÑĞ¾Ñ‚Ñƒ textarea Ğ¿Ğ¾ÑĞ»Ğµ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¸
    messageInput.style.height = 'auto';
    adjustTextareaHeight(messageInput);
}

function addMessageToUI(message) {
    const messagesContainer = document.getElementById('messagesContainer');

    if (!messagesContainer) {
        console.error('Messages container element not found');
        return;
    }

    const messageGroup = document.createElement('div');
    messageGroup.className = 'message-group';
    messageGroup.setAttribute('data-message-id', message.id || Date.now());

    const avatar = document.createElement('div');
    avatar.className = 'message-avatar';
    avatar.textContent = message.avatar;

    const content = document.createElement('div');
    content.className = 'message-content';

    const header = document.createElement('div');
    header.className = 'message-header';

    const author = document.createElement('span');
    author.className = 'message-author';
    author.textContent = message.author;

    const timestamp = document.createElement('span');
    timestamp.className = 'message-timestamp';
    timestamp.textContent = formatTimestamp(message.timestamp);

    const text = document.createElement('div');
    text.className = 'message-text';

    // Process the message text to handle quotes
    const processedText = formatQuotedText(message.text);

    // Set the HTML content to display formatted quotes
    text.innerHTML = processedText;

    // If the message contains a file, add it to the message
    if (message.file) {
        const fileDiv = document.createElement('div');
        fileDiv.className = 'file-attachment';

        // Determine file type and show appropriate preview/icon
        const fileExtension = message.file.filename.split('.').pop().toLowerCase();
        const imageExtensions = ['jpg', 'jpeg', 'png', 'gif', 'webp', 'svg'];
        const videoExtensions = ['mp4', 'webm', 'mov', 'avi'];
        const audioExtensions = ['mp3', 'wav', 'ogg', 'flac'];
        // ĞĞ¿Ñ€ĞµĞ´ĞµĞ»ÑĞµĞ¼, ÑĞ²Ğ»ÑĞµÑ‚ÑÑ Ğ»Ğ¸ Ñ„Ğ°Ğ¹Ğ» Ñ‚ĞµĞºÑÑ‚Ğ¾Ğ²Ñ‹Ğ¼ Ğ¿Ğ¾ MIME-Ñ‚Ğ¸Ğ¿Ñƒ Ğ¸Ğ»Ğ¸ Ñ€Ğ°ÑÑˆĞ¸Ñ€ĞµĞ½Ğ¸Ñ
        function isTextFile(file) {
            // ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ¿Ğ¾ MIME-Ñ‚Ğ¸Ğ¿Ñƒ
            if (file.type) {
                // Ğ›ÑĞ±Ğ¾Ğ¹ MIME-Ñ‚Ğ¸Ğ¿, Ğ½Ğ°Ñ‡Ğ¸Ğ½Ğ°ÑÑ‰Ğ¸Ğ¹ÑÑ Ñ "text/" - Ñ‚ĞµĞºÑÑ‚Ğ¾Ğ²Ñ‹Ğ¹ Ñ„Ğ°Ğ¹Ğ»
                if (file.type.startsWith('text/')) {
                    return true;
                }
                // ĞĞµĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ Ğ´Ğ²Ğ¾Ğ¸Ñ‡Ğ½Ñ‹Ğµ Ñ„Ğ°Ğ¹Ğ»Ñ‹ Ğ¼Ğ¾Ğ³ÑƒÑ‚ Ğ¸Ğ¼ĞµÑ‚ÑŒ Ñ€Ğ°ÑÑˆĞ¸Ñ€ĞµĞ½Ğ¸Ğµ, Ğ½Ğ¾ Ğ½Ğµ MIME-Ñ‚Ğ¸Ğ¿
                // ĞŸĞ¾ÑÑ‚Ğ¾Ğ¼Ñƒ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ¸ Ğ¿Ğ¾Ğ¿ÑƒĞ»ÑÑ€Ğ½Ñ‹Ğµ Ñ‚ĞµĞºÑÑ‚Ğ¾Ğ²Ñ‹Ğµ MIME-Ñ‚Ğ¸Ğ¿Ñ‹
                const textMimeTypes = [
                    'application/json', 'application/javascript', 'application/xml',
                    'application/x-sh', 'application/x-shellscript', 'application/octet-stream',
                    'application/x-msdownload', 'application/x-executable', 'application/x-makesys',
                    'application/x-msdownload', 'binary/octet-stream'
                ];
                if (textMimeTypes.includes(file.type)) {
                    // Ğ”Ğ»Ñ Ğ½ĞµĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ñ… Ñ‚Ğ¸Ğ¿Ğ¾Ğ², ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ Ğ¼Ğ¾Ğ³ÑƒÑ‚ Ğ±Ñ‹Ñ‚ÑŒ Ñ‚ĞµĞºÑÑ‚Ğ¾Ğ²Ñ‹Ğ¼Ğ¸, Ğ´Ğ¾Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ñ€Ğ°ÑÑˆĞ¸Ñ€ĞµĞ½Ğ¸Ğµ
                    const fileExtension = file.filename.split('.').pop().toLowerCase();
                    const textExtensions = ['sh', 'log', 'js', 'json', 'xml', 'csv', 'md', 'html', 'css', 'sql', 'py', 'java', 'cpp', 'c', 'h', 'hpp', 'ts', 'tsx', 'jsx', 'yaml', 'yml', 'ini', 'cfg', 'conf', 'bat', 'ps1', 'bash', 'zsh', 'pl', 'rb', 'php', 'asp', 'aspx', 'sql', 'sqlitedb', 'env', 'toml', 'lock'];
                    return textExtensions.includes(fileExtension);
                }
            }

            // ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ¿Ğ¾ Ñ€Ğ°ÑÑˆĞ¸Ñ€ĞµĞ½Ğ¸Ñ
            const textExtensions = ['txt', 'pdf', 'doc', 'docx', 'sh', 'log', 'js', 'py', 'html', 'css', 'json', 'xml', 'csv', 'md', 'sql', 'java', 'cpp', 'c', 'h', 'hpp', 'ts', 'tsx', 'jsx', 'yaml', 'yml', 'ini', 'cfg', 'conf', 'bat', 'ps1', 'bash', 'zsh', 'pl', 'rb', 'php', 'asp', 'aspx', 'sql', 'sqlitedb', 'env', 'toml', 'lock'];
            const fileExtension = file.filename.split('.').pop().toLowerCase();
            return textExtensions.includes(fileExtension);
        }

        if (imageExtensions.includes(fileExtension)) {
            // Image preview
            const img = document.createElement('img');
            img.src = message.file.url;
            img.alt = message.file.filename;
            img.className = 'file-preview-image';
            img.style.maxWidth = '300px';
            img.style.maxHeight = '300px';
            img.style.borderRadius = '8px';
            img.style.marginTop = '10px';

            // Add click handler to open image in new tab
            img.addEventListener('click', () => {
                window.open(message.file.url, '_blank');
            });

            fileDiv.appendChild(img);
        } else if (videoExtensions.includes(fileExtension)) {
            // Video preview
            const video = document.createElement('video');
            video.src = message.file.url;
            video.controls = true;
            video.className = 'file-preview-video';
            video.style.maxWidth = '300px';
            video.style.maxHeight = '300px';
            video.style.borderRadius = '8px';
            video.style.marginTop = '10px';

            fileDiv.appendChild(video);
        } else if (audioExtensions.includes(fileExtension)) {
            // Audio preview
            const audio = document.createElement('audio');
            audio.src = message.file.url;
            audio.controls = true;
            audio.className = 'file-preview-audio';
            audio.style.width = '100%';
            audio.style.marginTop = '10px';

            fileDiv.appendChild(audio);
        } else if (isTextFile(message.file)) {
            // For text-based files, create a preview with a snippet
            const filePreview = document.createElement('div');
            filePreview.className = 'file-preview-text';
            filePreview.style.marginTop = '10px';
            filePreview.style.padding = '10px';
            filePreview.style.backgroundColor = 'rgba(255, 255, 255, 0.1)';
            filePreview.style.borderRadius = '4px';
            filePreview.style.maxWidth = '300px';

            // Create file info header
            const fileInfo = document.createElement('div');
            fileInfo.className = 'file-info';
            fileInfo.style.fontWeight = 'bold';
            fileInfo.style.marginBottom = '5px';
            fileInfo.textContent = `ğŸ“„ ${message.file.filename}`;

            // Create a preview of the file content (first 100 characters)
            const fileContentPreview = document.createElement('div');
            fileContentPreview.className = 'file-content-preview';
            fileContentPreview.style.fontSize = '14px';
            fileContentPreview.style.whiteSpace = 'pre-wrap';
            fileContentPreview.style.overflow = 'hidden';
            fileContentPreview.style.textOverflow = 'ellipsis';
            fileContentPreview.style.maxHeight = '60px';

            // Create a link to download/view the full file
            const fileLink = document.createElement('a');
            fileLink.href = message.file.url;
            fileLink.textContent = 'Download/View Full File';
            fileLink.target = '_blank';
            fileLink.rel = 'noopener noreferrer';
            fileLink.style.display = 'inline-block';
            fileLink.style.marginTop = '5px';
            fileLink.style.color = '#74c0fc';
            fileLink.style.textDecoration = 'none';

            // Add click handler to open file in new tab
            fileLink.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent triggering parent click handlers
            });

            // Add elements to the preview container
            filePreview.appendChild(fileInfo);
            filePreview.appendChild(fileContentPreview);
            filePreview.appendChild(fileLink);

            // Attempt to fetch a small portion of the text file for preview
            fetch(`${message.file.url}?t=${Date.now()}`, {
                cache: 'no-cache'
            })
                .then(response => response.text())
                .then(fileText => {
                    // Take first 100 characters and add ellipsis if needed
                    const previewText = fileText.length > 100 ?
                        fileText.substring(0, 100) + '...' :
                        fileText;
                    fileContentPreview.textContent = previewText;
                })
                .catch(error => {
                    console.error('Could not load file preview:', error);
                    fileContentPreview.textContent = '[Unable to load preview]';
                });

            fileDiv.appendChild(filePreview);
        } else {
            // Generic file link
            const fileLink = document.createElement('a');
            fileLink.href = message.file.url;
            fileLink.textContent = `ğŸ“„ ${message.file.filename}`;
            fileLink.target = '_blank';
            fileLink.rel = 'noopener noreferrer';
            fileLink.className = 'file-link';
            fileLink.style.display = 'block';
            fileLink.style.padding = '8px';
            fileLink.style.backgroundColor = 'rgba(255, 255, 255, 0.1)';
            fileLink.style.borderRadius = '4px';
            fileLink.style.marginTop = '8px';
            fileLink.style.textDecoration = 'none';
            fileLink.style.color = '#74c0fc';

            fileDiv.appendChild(fileLink);
        }

        content.appendChild(fileDiv);
    }

    const reactionsContainer = document.createElement('div');
    reactionsContainer.className = 'message-reactions';

    // Add existing reactions to the message
    if (message.reactions && message.reactions.length > 0) {
        message.reactions.forEach(reaction => {
            const reactionEl = document.createElement('div');
            reactionEl.className = 'reaction';
            reactionEl.innerHTML = `${reaction.emoji} <span>${reaction.count}</span>`;
            reactionEl.title = reaction.users;

            // Ğ”Ğ»Ñ Self Chat Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ñ€ĞµĞ°ĞºÑ†Ğ¸Ğ¹ Ğ±ÑƒĞ´ĞµÑ‚ Ğ¾Ñ‚Ğ»Ğ¸Ñ‡Ğ°Ñ‚ÑŒÑÑ
            if (currentDMUserId === currentUser.id) {
                // Ğ’ Self Chat Ğ¿Ñ€Ğ¾ÑÑ‚Ğ¾ ÑƒĞ´Ğ°Ğ»ÑĞµĞ¼ Ñ€ĞµĞ°ĞºÑ†Ğ¸Ñ Ğ¿Ñ€Ğ¸ ĞºĞ»Ğ¸ĞºĞµ
                reactionEl.addEventListener('click', () => {
                    removeSelfChatReaction(message.id, reaction.emoji);
                });
            } else {
                // Ğ”Ğ»Ñ Ğ¾Ğ±Ñ‹Ñ‡Ğ½Ñ‹Ñ… DM Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ Ñ‡ĞµÑ€ĞµĞ· ÑĞ¾ĞºĞµÑ‚
                reactionEl.addEventListener('click', () => {
                    if (socket && socket.connected) {
                        socket.emit('remove-reaction', { messageId: message.id, emoji: reaction.emoji });
                    }
                });
            }
            reactionsContainer.appendChild(reactionEl);
        });
    }

    const addReactionBtn = document.createElement('button');
    addReactionBtn.className = 'add-reaction-btn';
    addReactionBtn.textContent = 'ğŸ˜Š';
    addReactionBtn.title = 'Add reaction';
    addReactionBtn.onclick = () => showEmojiPickerForMessage(message.id || Date.now());

    header.appendChild(author);
    header.appendChild(timestamp);
    content.appendChild(header);
    content.appendChild(text);

    // Create a container for reactions
    const reactionsAndActionsContainer = document.createElement('div');
    reactionsAndActionsContainer.className = 'reactions-and-actions-container';
    reactionsAndActionsContainer.appendChild(reactionsContainer);

    // Add reply button
    const replyBtn = document.createElement('button');
    replyBtn.className = 'reply-btn';
    replyBtn.textContent = 'â†ª';  // Right arrow for reply
    replyBtn.title = 'Reply to message';
    replyBtn.onclick = () => replyToMessage(message);

    // Create a container for action buttons to position them properly
    const actionsContainer = document.createElement('div');
    actionsContainer.className = 'message-actions';
    actionsContainer.appendChild(replyBtn);
    actionsContainer.appendChild(addReactionBtn);
    reactionsAndActionsContainer.appendChild(actionsContainer);
    content.appendChild(reactionsAndActionsContainer);

    messageGroup.appendChild(avatar);
    messageGroup.appendChild(content);

    messagesContainer.appendChild(messageGroup);

    if (typeof twemoji !== 'undefined') {
        twemoji.parse(messageGroup);
    }
}

function formatTimestamp(date) {
    const messageDate = new Date(date);
    const hours = messageDate.getHours().toString().padStart(2, '0');
    const minutes = messageDate.getMinutes().toString().padStart(2, '0');
    return `Today at ${hours}:${minutes}`;
}


// Function to reply to a message
function replyToMessage(message) {
    const messageInput = document.getElementById('messageInput');

    if (!messageInput) {
        console.error('Message input element not found');
        return;
    }

    // Format the reply message
    const replyText = `> **${message.author}**: ${message.text}\n\n`;

    // Insert the reply text at the beginning of the input
    const currentValue = messageInput.value;
    messageInput.value = replyText + currentValue;

    // Focus the input and move cursor to the end
    messageInput.focus();
    messageInput.setSelectionRange(messageInput.value.length, messageInput.value.length);

    // Adjust textarea height
    adjustTextareaHeight(messageInput);
}

// Function to handle reply to selected text
function setupReplyToSelection() {
    document.addEventListener('mouseup', function() {
        const selection = window.getSelection();
        if (selection.toString().trim() !== '') {
            // Create a temporary button to allow replying to selection
            const range = selection.getRangeAt(0);
            const rect = range.getBoundingClientRect();

            // Create reply button for selection
            const replyButton = document.createElement('button');
            replyButton.className = 'reply-selection-btn';
            replyButton.textContent = 'â†ª';
            replyButton.title = 'Reply to selection';
            replyButton.style.position = 'fixed';
            replyButton.style.left = rect.left + 'px';
            replyButton.style.top = (rect.top - 30) + 'px';
            replyButton.style.zIndex = '1000';
            replyButton.style.background = 'var(--accent)';
            replyButton.style.color = 'white';
            replyButton.style.border = 'none';
            replyButton.style.borderRadius = '50%';
            replyButton.style.width = '30px';
            replyButton.style.height = '30px';
            replyButton.style.cursor = 'pointer';

            replyButton.onclick = function() {
                const selectedText = selection.toString();
                const messageInput = document.getElementById('messageInput');

                if (messageInput) {
                    // Find the message that contains the selection
                    const messageElement = selection.anchorNode.parentElement.closest('.message-group');
                    let author = 'Unknown';

                    if (messageElement) {
                        const authorElement = messageElement.querySelector('.message-author');
                        if (authorElement) {
                            author = authorElement.textContent;
                        }
                    }

                    // Format the reply to selection
                    const replyText = `> **${author}**: ${selectedText}\n\n`;

                    const currentValue = messageInput.value;
                    messageInput.value = replyText + currentValue;

                    messageInput.focus();
                    messageInput.setSelectionRange(messageInput.value.length, messageInput.value.length);
                    adjustTextareaHeight(messageInput);
                }

                document.body.removeChild(replyButton);
            };

            document.body.appendChild(replyButton);

            // Remove button after a short time
            setTimeout(() => {
                if (replyButton.parentNode) {
                    document.body.removeChild(replyButton);
                }
            }, 3000);
        }
    });
}

// Function to parse and format replied messages for display
function formatQuotedText(text) {
    // Split text into lines
    const lines = text.split('\n');
    let formattedLines = [];

    for (let i = 0; i < lines.length; i++) {
        const line = lines[i];

        // Check if the line is a quoted/replied line
        if (line.startsWith('> ')) {
            // Extract the quoted content
            let quotedContent = line.substring(2); // Remove '> '

            // Check if it's a formatted quote with author
            if (quotedContent.startsWith('**') && quotedContent.includes('**: ')) {
                const colonIndex = quotedContent.indexOf('**: ');
                if (colonIndex !== -1) {
                    const author = quotedContent.substring(2, colonIndex); // Remove '**'
                    const quoteText = quotedContent.substring(colonIndex + 4); // Remove '**author**: '

                    formattedLines.push(`<div class="quoted-message"><span class="quote-author">**${escapeHtml(author)}**:</span> ${escapeHtml(quoteText)}</div>`);
                } else {
                    // Simple quote without author
                    formattedLines.push(`<div class="quoted-message">${escapeHtml(quotedContent)}</div>`);
                }
            } else {
                // Simple quote without author
                formattedLines.push(`<div class="quoted-message">${escapeHtml(quotedContent)}</div>`);
            }
        } else {
            // Regular text line
            formattedLines.push(escapeHtml(line));
        }
    }

    return formattedLines.join('');
}

// Helper function to escape HTML to prevent XSS
function escapeHtml(text) {
    return text
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
}

function scrollToBottom() {
    const messagesContainer = document.getElementById('messagesContainer');
    if (messagesContainer) {
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }
}

// Emoji picker
function initializeEmojiPicker() {
    const emojiBtn = document.querySelector('.emoji-btn');
    if (emojiBtn) {
        emojiBtn.addEventListener('click', () => {
            showEmojiPickerForInput();
        });
    }
}

const EMOJI_CATEGORIES = {
    'smileys': {
        icon: 'ğŸ˜€',
        name: 'Smileys & Emotion',
        emojis: ['ğŸ˜€', 'ğŸ˜ƒ', 'ğŸ˜„', 'ğŸ˜', 'ğŸ˜†', 'ğŸ˜…', 'ğŸ¤£', 'ğŸ˜‚', 'ğŸ™‚', 'ğŸ™ƒ', 'ğŸ˜‰', 'ğŸ˜Š', 'ğŸ˜‡', 'ğŸ¥°', 'ğŸ˜', 'ğŸ¤©', 'ğŸ˜˜', 'ğŸ˜—', 'â˜ºï¸', 'ğŸ˜š', 'ğŸ˜™', 'ğŸ¥²', 'ğŸ˜‹', 'ğŸ˜›', 'ğŸ˜œ', 'ğŸ¤ª', 'ğŸ˜', 'ğŸ¤‘', 'ğŸ¤—', 'ğŸ¤­', 'ğŸ¤«', 'ğŸ¤”', 'ğŸ¤', 'ğŸ¤¨', 'ğŸ˜', 'ğŸ˜‘', 'ğŸ˜¶', 'ğŸ˜', 'ğŸ˜’', 'ğŸ™„', 'ğŸ˜¬', 'ğŸ¤¥', 'ğŸ˜Œ', 'ğŸ˜”', 'ğŸ˜ª', 'ğŸ¤¤', 'ğŸ˜´', 'ğŸ˜·', 'ğŸ¤’', 'ğŸ¤•', 'ğŸ¤¢', 'ğŸ¤®', 'ğŸ¤§', 'ğŸ¥µ', 'ğŸ¥¶', 'ğŸ¥´', 'ğŸ˜µ', 'ğŸ¤¯', 'ğŸ¤ ', 'ğŸ¥³', 'ğŸ¥¸', 'ğŸ˜', 'ğŸ¤“', 'ğŸ§', 'ğŸ˜•', 'ğŸ˜Ÿ', 'ğŸ™', 'â˜¹ï¸', 'ğŸ˜®', 'ğŸ˜¯', 'ğŸ˜²', 'ğŸ˜³', 'ğŸ¥º', 'ğŸ˜¦', 'ğŸ˜§', 'ğŸ˜¨', 'ğŸ˜°', 'ğŸ˜¥', 'ğŸ˜¢', 'ğŸ˜­', 'ğŸ˜±', 'ğŸ˜–', 'ğŸ˜£', 'ğŸ˜', 'ğŸ˜“', 'ğŸ˜©', 'ğŸ˜«', 'ğŸ¥±', 'ğŸ˜¤', 'ğŸ˜¡', 'ğŸ˜ ', 'ğŸ¤¬', 'ğŸ˜ˆ', 'ğŸ‘¿', 'ğŸ’€', 'â˜ ï¸', 'ğŸ’©', 'ğŸ¤¡', 'ğŸ‘¹', 'ğŸ‘º', 'ğŸ‘»', 'ğŸ‘½', 'ğŸ‘¾', 'ğŸ¤–', 'ğŸ˜º', 'ğŸ˜¸', 'ğŸ˜¹', 'ğŸ˜»', 'ğŸ˜¼', 'ğŸ˜½', 'ğŸ™€', 'ğŸ˜¿', 'ğŸ˜¾']
    },
    'people': {
        icon: 'ğŸ‘‹',
        name: 'People & Body',
        emojis: ['ğŸ‘‹', 'ğŸ¤š', 'ğŸ–ï¸', 'âœ‹', 'ğŸ––', 'ğŸ‘Œ', 'ğŸ¤Œ', 'ğŸ¤', 'âœŒï¸', 'ğŸ¤', 'ğŸ¤Ÿ', 'ğŸ¤˜', 'ğŸ¤™', 'ğŸ‘ˆ', 'ğŸ‘‰', 'ğŸ‘†', 'ğŸ–•', 'ğŸ‘‡', 'â˜ï¸', 'ğŸ‘', 'ğŸ‘', 'âœŠ', 'ğŸ‘Š', 'ğŸ¤›', 'ğŸ¤œ', 'ğŸ‘', 'ğŸ™Œ', 'ğŸ‘', 'ğŸ¤²', 'ğŸ¤', 'ğŸ™', 'âœï¸', 'ğŸ’…', 'ğŸ¤³', 'ğŸ’ª', 'ğŸ¦¾', 'ğŸ¦¿', 'ğŸ¦µ', 'ğŸ¦¶', 'ğŸ‘‚', 'ğŸ¦»', 'ğŸ‘ƒ', 'ğŸ§ ', 'ğŸ«€', 'ğŸ«', 'ğŸ¦·', 'ğŸ¦´', 'ğŸ‘€', 'ğŸ‘ï¸', 'ğŸ‘…', 'ğŸ‘„', 'ğŸ‘¶', 'ğŸ§’', 'ğŸ‘¦', 'ğŸ‘§', 'ğŸ§‘', 'ğŸ‘±', 'ğŸ‘¨', 'ğŸ§”', 'ğŸ‘©', 'ğŸ§“', 'ğŸ‘´', 'ğŸ‘µ', 'ğŸ™', 'ğŸ™', 'ğŸ™…', 'ğŸ™†', 'ğŸ’', 'ğŸ™‹', 'ğŸ§', 'ğŸ™‡', 'ğŸ¤¦', 'ğŸ¤·', 'ğŸ‘®', 'ğŸ•µï¸', 'ğŸ’‚', 'ğŸ¥·', 'ğŸ‘·', 'ğŸ¤´', 'ğŸ‘¸', 'ğŸ‘³', 'ğŸ‘²', 'ğŸ§•', 'ğŸ¤µ', 'ğŸ‘°', 'ğŸ¤°', 'ğŸ¤±', 'ğŸ‘¼', 'ğŸ…', 'ğŸ¤¶', 'ğŸ¦¸', 'ğŸ¦¹', 'ğŸ§™', 'ğŸ§š', 'ğŸ§›', 'ğŸ§œ', 'ğŸ§', 'ğŸ§', 'ğŸ§Ÿ', 'ğŸ’†', 'ğŸ’‡', 'ğŸš¶', 'ğŸ§', 'ğŸ§', 'ğŸƒ', 'ğŸ’ƒ', 'ğŸ•º', 'ğŸ•´ï¸', 'ğŸ‘¯', 'ğŸ§–', 'ğŸ§—', 'ğŸ¤¸', 'ğŸŒï¸', 'ğŸ‡', 'â›·ï¸', 'ğŸ‚', 'ğŸ‹ï¸', 'ğŸ¤¼', 'ğŸ¤½', 'ğŸ¤¾', 'ğŸ¤º', 'â›¹ï¸', 'ğŸŠ', 'ğŸš£', 'ğŸ§˜', 'ğŸ›€', 'ğŸ›Œ', 'ğŸ‘­', 'ğŸ‘«', 'ğŸ‘¬', 'ğŸ’', 'ğŸ’‘', 'ğŸ‘ª', 'ğŸ‘¨â€ğŸ‘©â€ğŸ‘¦', 'ğŸ‘¨â€ğŸ‘©â€ğŸ‘§', 'ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦', 'ğŸ‘¨â€ğŸ‘©â€ğŸ‘¦â€ğŸ‘¦', 'ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘§', 'ğŸ‘¨â€ğŸ‘¦', 'ğŸ‘¨â€ğŸ‘¦â€ğŸ‘¦', 'ğŸ‘¨â€ğŸ‘§', 'ğŸ‘¨â€ğŸ‘§â€ğŸ‘¦', 'ğŸ‘¨â€ğŸ‘§â€ğŸ‘§', 'ğŸ‘©â€ğŸ‘¦', 'ğŸ‘©â€ğŸ‘¦â€ğŸ‘¦', 'ğŸ‘©â€ğŸ‘§', 'ğŸ‘©â€ğŸ‘§â€ğŸ‘¦', 'ğŸ‘©â€ğŸ‘§â€ğŸ‘§', 'ğŸ—£ï¸', 'ğŸ‘¤', 'ğŸ‘¥', 'ğŸ«‚', 'ğŸ‘£']
    },
    'animals': {
        icon: 'ğŸ¶',
        name: 'Animals & Nature',
        emojis: ['ğŸ¶', 'ğŸ•', 'ğŸ¦®', 'ğŸ•â€ğŸ¦º', 'ğŸ©', 'ğŸº', 'ğŸ¦Š', 'ğŸ¦', 'ğŸ±', 'ğŸˆ', 'ğŸˆâ€â¬›', 'ğŸ¦', 'ğŸ¯', 'ğŸ…', 'ğŸ†', 'ğŸ´', 'ğŸ', 'ğŸ¦„', 'ğŸ¦“', 'ğŸ¦Œ', 'ğŸ¦¬', 'ğŸ®', 'ğŸ‚', 'ğŸƒ', 'ğŸ„', 'ğŸ·', 'ğŸ–', 'ğŸ—', 'ğŸ½', 'ğŸ', 'ğŸ‘', 'ğŸ', 'ğŸª', 'ğŸ«', 'ğŸ¦™', 'ğŸ¦’', 'ğŸ˜', 'ğŸ¦£', 'ğŸ¦', 'ğŸ¦›', 'ğŸ­', 'ğŸ', 'ğŸ€', 'ğŸ¹', 'ğŸ°', 'ğŸ‡', 'ğŸ¿ï¸', 'ğŸ¦«', 'ğŸ¦”', 'ğŸ¦‡', 'ğŸ»', 'ğŸ»â€â„ï¸', 'ğŸ¨', 'ğŸ¼', 'ğŸ¦¥', 'ğŸ¦¦', 'ğŸ¦¨', 'ğŸ¦˜', 'ğŸ¦¡', 'ğŸ¾', 'ğŸ¦ƒ', 'ğŸ”', 'ğŸ“', 'ğŸ£', 'ğŸ¤', 'ğŸ¥', 'ğŸ¦', 'ğŸ§', 'ğŸ•Šï¸', 'ğŸ¦…', 'ğŸ¦†', 'ğŸ¦¢', 'ğŸ¦‰', 'ğŸ¦¤', 'ğŸª¶', 'ğŸ¦©', 'ğŸ¦š', 'ğŸ¦œ', 'ğŸ¸', 'ğŸŠ', 'ğŸ¢', 'ğŸ¦', 'ğŸ', 'ğŸ²', 'ğŸ‰', 'ğŸ¦•', 'ğŸ¦–', 'ğŸ³', 'ğŸ‹', 'ğŸ¬', 'ğŸ¦­', 'ğŸŸ', 'ğŸ ', 'ğŸ¡', 'ğŸ¦ˆ', 'ğŸ™', 'ğŸš', 'ğŸŒ', 'ğŸ¦‹', 'ğŸ›', 'ğŸœ', 'ğŸ', 'ğŸª²', 'ğŸ', 'ğŸ¦—', 'ğŸª³', 'ğŸ•·ï¸', 'ğŸ•¸ï¸', 'ğŸ¦‚', 'ğŸ¦Ÿ', 'ğŸª°', 'ğŸª±', 'ğŸ¦ ', 'ğŸ’', 'ğŸŒ¸', 'ğŸ’®', 'ğŸµï¸', 'ğŸŒ¹', 'ğŸ¥€', 'ğŸŒº', 'ğŸŒ»', 'ğŸŒ¼', 'ğŸŒ·', 'ğŸŒ±', 'ğŸª´', 'ğŸŒ²', 'ğŸŒ³', 'ğŸŒ´', 'ğŸŒµ', 'ğŸŒ¾', 'ğŸŒ¿', 'â˜˜ï¸', 'ğŸ€', 'ğŸ', 'ğŸ‚', 'ğŸƒ']
    },
    'food': {
        icon: 'ğŸ”',
        name: 'Food & Drink',
        emojis: ['ğŸ‡', 'ğŸˆ', 'ğŸ‰', 'ğŸŠ', 'ğŸ‹', 'ğŸŒ', 'ğŸ', 'ğŸ¥­', 'ğŸ', 'ğŸ', 'ğŸ', 'ğŸ‘', 'ğŸ’', 'ğŸ“', 'ğŸ«', 'ğŸ¥', 'ğŸ…', 'ğŸ«’', 'ğŸ¥¥', 'ğŸ¥‘', 'ğŸ†', 'ğŸ¥”', 'ğŸ¥•', 'ğŸŒ½', 'ğŸŒ¶ï¸', 'ğŸ«‘', 'ğŸ¥’', 'ğŸ¥¬', 'ğŸ¥¦', 'ğŸ§„', 'ğŸ§…', 'ğŸ„', 'ğŸ¥œ', 'ğŸŒ°', 'ğŸ', 'ğŸ¥', 'ğŸ¥–', 'ğŸ«“', 'ğŸ¥¨', 'ğŸ¥¯', 'ğŸ¥', 'ğŸ§‡', 'ğŸ§€', 'ğŸ–', 'ğŸ—', 'ğŸ¥©', 'ğŸ¥“', 'ğŸ”', 'ğŸŸ', 'ğŸ•', 'ğŸŒ­', 'ğŸ¥ª', 'ğŸŒ®', 'ğŸŒ¯', 'ğŸ«”', 'ğŸ¥™', 'ğŸ§†', 'ğŸ¥š', 'ğŸ³', 'ğŸ¥˜', 'ğŸ²', 'ğŸ«•', 'ğŸ¥£', 'ğŸ¥—', 'ğŸ¿', 'ğŸ§ˆ', 'ğŸ§‚', 'ğŸ¥«', 'ğŸ±', 'ğŸ˜', 'ğŸ™', 'ğŸš', 'ğŸ›', 'ğŸœ', 'ğŸ', 'ğŸ ', 'ğŸ¢', 'ğŸ£', 'ğŸ¤', 'ğŸ¥', 'ğŸ¥®', 'ğŸ¡', 'ğŸ¥Ÿ', 'ğŸ¥ ', 'ğŸ¥¡', 'ğŸ¦€', 'ğŸ¦', 'ğŸ¦', 'ğŸ¦‘', 'ğŸ¦ª', 'ğŸ¦', 'ğŸ§', 'ğŸ¨', 'ğŸ©', 'ğŸª', 'ğŸ‚', 'ğŸ°', 'ğŸ§', 'ğŸ¥§', 'ğŸ«', 'ğŸ¬', 'ğŸ­', 'ğŸ®', 'ğŸ¯', 'ğŸ¼', 'ğŸ¥›', 'â˜•', 'ğŸ«–', 'ğŸµ', 'ğŸ¶', 'ğŸ¾', 'ğŸ·', 'ğŸ¸', 'ğŸ¹', 'ğŸº', 'ğŸ»', 'ğŸ¥‚', 'ğŸ¥ƒ', 'ğŸ¥¤', 'ğŸ§‹', 'ğŸ§ƒ', 'ğŸ§‰', 'ğŸ§Š', 'ğŸ¥¢', 'ğŸ½ï¸', 'ğŸ´', 'ğŸ¥„']
    },
    'activities': {
        icon: 'âš½',
        name: 'Activities',
        emojis: ['âš½', 'ğŸ€', 'ğŸˆ', 'âš¾', 'ğŸ¥', 'ğŸ¾', 'ğŸ', 'ğŸ‰', 'ğŸ¥', 'ğŸ±', 'ğŸª€', 'ğŸ“', 'ğŸ¸', 'ğŸ’', 'ğŸ‘', 'ğŸ¥', 'ğŸ', 'ğŸªƒ', 'ğŸ¥…', 'â›³', 'ğŸª', 'ğŸ¹', 'ğŸ£', 'ğŸ¤¿', 'ğŸ¥Š', 'ğŸ¥‹', 'ğŸ½', 'ğŸ›¹', 'ğŸ›¼', 'ğŸ›·', 'â›¸ï¸', 'ğŸ¥Œ', 'ğŸ¿', 'â›·ï¸', 'ğŸ‚', 'ğŸª‚', 'ğŸ‹ï¸', 'ğŸ¤¼', 'ğŸ¤¸', 'â›¹ï¸', 'ğŸ¤¾', 'ğŸŒï¸', 'ğŸ‡', 'ğŸ§˜', 'ğŸ„', 'ğŸŠ', 'ğŸ¤½', 'ğŸš£', 'ğŸ§—', 'ğŸšµ', 'ğŸš´', 'ğŸ†', 'ğŸ¥‡', 'ğŸ¥ˆ', 'ğŸ¥‰', 'ğŸ…', 'ğŸ–ï¸', 'ğŸµï¸', 'ğŸ—ï¸', 'ğŸ«', 'ğŸŸï¸', 'ğŸª', 'ğŸ¤¹', 'ğŸ­', 'ğŸ©°', 'ğŸ¨', 'ğŸ¬', 'ğŸ¤', 'ğŸ§', 'ğŸ¼', 'ğŸ¹', 'ğŸ¥', 'ğŸª˜', 'ğŸ·', 'ğŸº', 'ğŸª—', 'ğŸ¸', 'ğŸª•', 'ğŸ»', 'ğŸ²', 'â™Ÿï¸', 'ğŸ¯', 'ğŸ³', 'ğŸ®', 'ğŸ°', 'ğŸ§©']
    },
    'travel': {
        icon: 'ğŸš—',
        name: 'Travel & Places',
        emojis: ['ğŸš—', 'ğŸš•', 'ğŸš™', 'ğŸšŒ', 'ğŸš', 'ğŸï¸', 'ğŸš“', 'ğŸš‘', 'ğŸš’', 'ğŸš', 'ğŸ›»', 'ğŸšš', 'ğŸš›', 'ğŸšœ', 'ğŸ¦¯', 'ğŸ¦½', 'ğŸ¦¼', 'ğŸ›´', 'ğŸš²', 'ğŸ›µ', 'ğŸï¸', 'ğŸ›º', 'ğŸš¨', 'ğŸš”', 'ğŸš', 'ğŸš˜', 'ğŸš–', 'ğŸš¡', 'ğŸš ', 'ğŸšŸ', 'ğŸšƒ', 'ğŸš‹', 'ğŸš', 'ğŸš', 'ğŸš„', 'ğŸš…', 'ğŸšˆ', 'ğŸš‚', 'ğŸš†', 'ğŸš‡', 'ğŸšŠ', 'ğŸš‰', 'âœˆï¸', 'ğŸ›«', 'ğŸ›¬', 'ğŸ›©ï¸', 'ğŸ’º', 'ğŸ›°ï¸', 'ğŸš€', 'ğŸ›¸', 'ğŸš', 'ğŸ›¶', 'â›µ', 'ğŸš¤', 'ğŸ›¥ï¸', 'ğŸ›³ï¸', 'â›´ï¸', 'ğŸš¢', 'âš“', 'ğŸª', 'â›½', 'ğŸš§', 'ğŸš¦', 'ğŸš¥', 'ğŸš', 'ğŸ—ºï¸', 'ğŸ—¿', 'ğŸ—½', 'ğŸ—¼', 'ğŸ°', 'ğŸ¯', 'ğŸŸï¸', 'ğŸ¡', 'ğŸ¢', 'ğŸ ', 'â›²', 'â›±ï¸', 'ğŸ–ï¸', 'ğŸï¸', 'ğŸœï¸', 'ğŸŒ‹', 'â›°ï¸', 'ğŸ”ï¸', 'ğŸ—»', 'ğŸ•ï¸', 'â›º', 'ğŸ›–', 'ğŸ ', 'ğŸ¡', 'ğŸ˜ï¸', 'ğŸšï¸', 'ğŸ—ï¸', 'ğŸ­', 'ğŸ¢', 'ğŸ¬', 'ğŸ£', 'ğŸ¤', 'ğŸ¥', 'ğŸ¦', 'ğŸ¨', 'ğŸª', 'ğŸ«', 'ğŸ©', 'ğŸ’’', 'ğŸ›ï¸', 'â›ª', 'ğŸ•Œ', 'ğŸ•', 'ğŸ›•', 'ğŸ•‹', 'â›©ï¸', 'ğŸ›¤ï¸', 'ğŸ›£ï¸', 'ğŸ—¾', 'ğŸ‘', 'ğŸï¸', 'ğŸŒ…', 'ğŸŒ„', 'ğŸŒ ', 'ğŸ‡', 'ğŸ†', 'ğŸŒ‡', 'ğŸŒ†', 'ğŸ™ï¸', 'ğŸŒƒ', 'ğŸŒŒ', 'ğŸŒ‰', 'ğŸŒ']
    },
    'objects': {
        icon: 'ğŸ’¡',
        name: 'Objects',
        emojis: ['âŒš', 'ğŸ“±', 'ğŸ“²', 'ğŸ’»', 'âŒ¨ï¸', 'ğŸ–¥ï¸', 'ğŸ–¨ï¸', 'ğŸ–±ï¸', 'ğŸ–²ï¸', 'ğŸ•¹ï¸', 'ğŸ—œï¸', 'ğŸ’½', 'ğŸ’¾', 'ğŸ’¿', 'ğŸ“€', 'ğŸ“¼', 'ğŸ“·', 'ğŸ“¸', 'ğŸ“¹', 'ğŸ¥', 'ğŸ“½ï¸', 'ğŸï¸', 'ğŸ“', 'â˜ï¸', 'ğŸ“Ÿ', 'ğŸ“ ', 'ğŸ“º', 'ğŸ“»', 'ğŸ™ï¸', 'ğŸšï¸', 'ğŸ›ï¸', 'ğŸ§­', 'â±ï¸', 'â²ï¸', 'â°', 'ğŸ•°ï¸', 'âŒ›', 'â³', 'ğŸ“¡', 'ğŸ”‹', 'ğŸ”Œ', 'ğŸ’¡', 'ğŸ”¦', 'ğŸ•¯ï¸', 'ğŸª”', 'ğŸ§¯', 'ğŸ›¢ï¸', 'ğŸ’¸', 'ğŸ’µ', 'ğŸ’´', 'ğŸ’¶', 'ğŸ’·', 'ğŸª™', 'ğŸ’°', 'ğŸ’³', 'ğŸ’', 'âš–ï¸', 'ğŸªœ', 'ğŸ§°', 'ğŸª›', 'ğŸ”§', 'ğŸ”¨', 'âš’ï¸', 'ğŸ› ï¸', 'â›ï¸', 'ğŸªš', 'ğŸ”©', 'âš™ï¸', 'ğŸª¤', 'ğŸ§±', 'â›“ï¸', 'ğŸ§²', 'ğŸ”«', 'ğŸ’£', 'ğŸ§¨', 'ğŸª“', 'ğŸ”ª', 'ğŸ—¡ï¸', 'âš”ï¸', 'ğŸ›¡ï¸', 'ğŸš¬', 'âš°ï¸', 'ğŸª¦', 'âš±ï¸', 'ğŸº', 'ğŸ”®', 'ğŸ“¿', 'ğŸ§¿', 'ğŸ’ˆ', 'âš—ï¸', 'ğŸ”­', 'ğŸ”¬', 'ğŸ•³ï¸', 'ğŸ©¹', 'ğŸ©º', 'ğŸ’Š', 'ğŸ’‰', 'ğŸ©¸', 'ğŸ§¬', 'ğŸ¦ ', 'ğŸ§«', 'ğŸ§ª', 'ğŸŒ¡ï¸', 'ğŸ§¹', 'ğŸª ', 'ğŸ§º', 'ğŸ§»', 'ğŸš½', 'ğŸš°', 'ğŸš¿', 'ğŸ›', 'ğŸ›€', 'ğŸ§¼', 'ğŸª¥', 'ğŸª’', 'ğŸ§½', 'ğŸª£', 'ğŸ§´', 'ğŸ›ï¸', 'ğŸ”‘', 'ğŸ—ï¸', 'ğŸšª', 'ğŸª‘', 'ğŸ›‹ï¸', 'ğŸ›ï¸', 'ğŸ›Œ', 'ğŸ§¸', 'ğŸª†', 'ğŸ–¼ï¸', 'ğŸª', 'ğŸªŸ', 'ğŸ›ï¸', 'ğŸ›’', 'ğŸ', 'ğŸˆ', 'ğŸ', 'ğŸ€', 'ğŸª„', 'ğŸª…', 'ğŸŠ', 'ğŸ‰', 'ğŸ', 'ğŸ®', 'ğŸ', 'ğŸ§§', 'âœ‰ï¸', 'ğŸ“©', 'ğŸ“¨', 'ğŸ“§', 'ğŸ’Œ', 'ğŸ“¥', 'ğŸ“¤', 'ğŸ“¦', 'ğŸ·ï¸', 'ğŸ“ª', 'ğŸ“«', 'ğŸ“¬', 'ğŸ“­', 'ğŸ“®', 'ğŸ“¯', 'ğŸ“œ', 'ğŸ“ƒ', 'ğŸ“„', 'ğŸ“‘', 'ğŸ§¾', 'ğŸ“Š', 'ğŸ“ˆ', 'ğŸ“‰', 'ğŸ—’ï¸', 'ğŸ—“ï¸', 'ğŸ“†', 'ğŸ“…', 'ğŸ—‘ï¸', 'ğŸ“‡', 'ğŸ—ƒï¸', 'ğŸ—³ï¸', 'ğŸ—„ï¸', 'ğŸ“‹', 'ğŸ“', 'ğŸ“‚', 'ğŸ—‚ï¸', 'ğŸ—ï¸', 'ğŸ“°', 'ğŸ““', 'ğŸ“”', 'ğŸ“’', 'ğŸ“•', 'ğŸ“—', 'ğŸ“˜', 'ğŸ“™', 'ğŸ“š', 'ğŸ“–', 'ğŸ”–', 'ğŸ§·', 'ğŸ”—', 'ğŸ“', 'ğŸ–‡ï¸', 'ğŸ“', 'ğŸ“', 'ğŸ§®', 'ğŸ“Œ', 'ğŸ“', 'âœ‚ï¸', 'ğŸ–Šï¸', 'ğŸ–‹ï¸', 'âœ’ï¸', 'ğŸ–Œï¸', 'ğŸ–ï¸', 'ğŸ“', 'âœï¸', 'ğŸ”', 'ğŸ”', 'ğŸ”', 'ğŸ”', 'ğŸ”’', 'ğŸ”“']
    },
    'symbols': {
        icon: 'â¤ï¸',
        name: 'Symbols',
        emojis: ['â¤ï¸', 'ğŸ§¡', 'ğŸ’›', 'ğŸ’š', 'ğŸ’™', 'ğŸ’œ', 'ğŸ–¤', 'ğŸ¤', 'ğŸ¤', 'ğŸ’”', 'â£ï¸', 'ğŸ’•', 'ğŸ’', 'ğŸ’“', 'ğŸ’—', 'ğŸ’–', 'ğŸ’˜', 'ğŸ’', 'ğŸ’Ÿ', 'â˜®ï¸', 'âœï¸', 'â˜ªï¸', 'ğŸ•‰ï¸', 'â˜¸ï¸', 'âœ¡ï¸', 'ğŸ”¯', 'ğŸ•', 'â˜¯ï¸', 'â˜¦ï¸', 'ğŸ›', 'â›', 'â™ˆ', 'â™‰', 'â™Š', 'â™‹', 'â™Œ', 'â™', 'â™', 'â™', 'â™', 'â™‘', 'â™’', 'â™“', 'ğŸ†”', 'âš›ï¸', 'ğŸ‰‘', 'â˜¢ï¸', 'â˜£ï¸', 'ğŸ“´', 'ğŸ“³', 'ğŸˆ¶', 'ğŸˆš', 'ğŸˆ¸', 'ğŸˆº', 'ğŸˆ·ï¸', 'âœ´ï¸', 'ğŸ†š', 'ğŸ’®', 'ğŸ‰', 'ãŠ™ï¸', 'ãŠ—ï¸', 'ğŸˆ´', 'ğŸˆµ', 'ğŸˆ¹', 'ğŸˆ²', 'ğŸ…°ï¸', 'ğŸ…±ï¸', 'ğŸ†', 'ğŸ†‘', 'ğŸ…¾ï¸', 'ğŸ†˜', 'âŒ', 'â­•', 'ğŸ›‘', 'â›”', 'ğŸ“›', 'ğŸš«', 'ğŸ’¯', 'ğŸ’¢', 'â™¨ï¸', 'ğŸš·', 'ğŸš¯', 'ğŸš³', 'ğŸš±', 'ğŸ”', 'ğŸ“µ', 'ğŸš­', 'â—', 'â•', 'â“', 'â”', 'â€¼ï¸', 'â‰ï¸', 'ğŸ”…', 'ğŸ”†', 'ã€½ï¸', 'âš ï¸', 'ğŸš¸', 'ğŸ”±', 'âšœï¸', 'ğŸ”°', 'â™»ï¸', 'âœ…', 'ğŸˆ¯', 'ğŸ’¹', 'â‡ï¸', 'âœ³ï¸', 'â', 'ğŸŒ', 'ğŸ’ ', 'â“‚ï¸', 'ğŸŒ€', 'ğŸ’¤', 'ğŸ§', 'ğŸš¾', 'â™¿', 'ğŸ…¿ï¸', 'ğŸ›—', 'ğŸˆ³', 'ğŸˆ‚ï¸', 'ğŸ›‚', 'ğŸ›ƒ', 'ğŸ›„', 'ğŸ›…', 'ğŸš¹', 'ğŸšº', 'ğŸš¼', 'âš§ï¸', 'ğŸš»', 'ğŸš®', 'ğŸ¦', 'ğŸ“¶', 'ğŸˆ', 'ğŸ”£', 'â„¹ï¸', 'ğŸ”¤', 'ğŸ”¡', 'ğŸ” ', 'ğŸ†–', 'ğŸ†—', 'ğŸ†™', 'ğŸ†’', 'ğŸ†•', 'ğŸ†“', '0ï¸âƒ£', '1ï¸âƒ£', '2ï¸âƒ£', '3ï¸âƒ£', '4ï¸âƒ£', '5ï¸âƒ£', '6ï¸âƒ£', '7ï¸âƒ£', '8ï¸âƒ£', '9ï¸âƒ£', 'ğŸ”Ÿ', 'ğŸ”¢', '#ï¸âƒ£', '*ï¸âƒ£', 'âï¸', 'â–¶ï¸', 'â¸ï¸', 'â¯ï¸', 'â¹ï¸', 'âºï¸', 'â­ï¸', 'â®ï¸', 'â©', 'âª', 'â«', 'â¬', 'â—€ï¸', 'ğŸ”¼', 'ğŸ”½', 'â¡ï¸', 'â¬…ï¸', 'â¬†ï¸', 'â¬‡ï¸', 'â†—ï¸', 'â†˜ï¸', 'â†™ï¸', 'â†–ï¸', 'â†•ï¸', 'â†”ï¸', 'â†ªï¸', 'â†©ï¸', 'â¤´ï¸', 'â¤µï¸', 'ğŸ”€', 'ğŸ”', 'ğŸ”‚', 'ğŸ”„', 'ğŸ”ƒ', 'ğŸµ', 'ğŸ¶', 'â•', 'â–', 'â—', 'âœ–ï¸', 'â™¾ï¸', 'ğŸ’²', 'ğŸ’±', 'â„¢ï¸', 'Â©ï¸', 'Â®ï¸', 'ã€°ï¸', 'â°', 'â¿', 'ğŸ”š', 'ğŸ”™', 'ğŸ”›', 'ğŸ”', 'ğŸ”œ', 'âœ”ï¸', 'â˜‘ï¸', 'ğŸ”˜', 'ğŸ”´', 'ğŸŸ ', 'ğŸŸ¡', 'ğŸŸ¢', 'ğŸ”µ', 'ğŸŸ£', 'âš«', 'âšª', 'ğŸŸ¤', 'ğŸ”º', 'ğŸ”»', 'ğŸ”¸', 'ğŸ”¹', 'ğŸ”¶', 'ğŸ”·', 'ğŸ”³', 'ğŸ”²', 'â–ªï¸', 'â–«ï¸', 'â—¾', 'â—½', 'â—¼ï¸', 'â—»ï¸', 'ğŸŸ¥', 'ğŸŸ§', 'ğŸŸ¨', 'ğŸŸ©', 'ğŸŸ¦', 'ğŸŸª', 'â¬›', 'â¬œ', 'ğŸŸ«', 'ğŸ”ˆ', 'ğŸ”‡', 'ğŸ”‰', 'ğŸ”Š', 'ğŸ””', 'ğŸ”•', 'ğŸ“£', 'ğŸ“¢', 'ğŸ‘â€ğŸ—¨', 'ğŸ’¬', 'ğŸ’­', 'ğŸ—¯ï¸', 'â™ ï¸', 'â™£ï¸', 'â™¥ï¸', 'â™¦ï¸', 'ğŸƒ', 'ğŸ´', 'ğŸ€„', 'ğŸ•', 'ğŸ•‘', 'ğŸ•’', 'ğŸ•“', 'ğŸ•”', 'ğŸ••', 'ğŸ•–', 'ğŸ•—', 'ğŸ•˜', 'ğŸ•™', 'ğŸ•š', 'ğŸ•›', 'ğŸ•œ', 'ğŸ•', 'ğŸ•', 'ğŸ•Ÿ', 'ğŸ• ', 'ğŸ•¡', 'ğŸ•¢', 'ğŸ•£', 'ğŸ•¤', 'ğŸ•¥', 'ğŸ•¦', 'ğŸ•§']
    },
    'flags': {
        icon: 'ğŸ³ï¸',
        name: 'Flags',
        emojis: ['ğŸ³ï¸', 'ğŸ´', 'ğŸ´â€â˜ ï¸', 'ğŸ', 'ğŸš©', 'ğŸŒ', 'ğŸ³ï¸â€ğŸŒˆ', 'ğŸ³ï¸â€âš§ï¸', 'ğŸ‡ºğŸ‡³', 'ğŸ‡¦ğŸ‡«', 'ğŸ‡¦ğŸ‡±', 'ğŸ‡©ğŸ‡¿', 'ğŸ‡¦ğŸ‡¸', 'ğŸ‡¦ğŸ‡©', 'ğŸ‡¦ğŸ‡´', 'ğŸ‡¦ğŸ‡®', 'ğŸ‡¦ğŸ‡¶', 'ğŸ‡¦ğŸ‡¬', 'ğŸ‡¦ğŸ‡·', 'ğŸ‡¦ğŸ‡²', 'ğŸ‡¦ğŸ‡¼', 'ğŸ‡¦ğŸ‡º', 'ğŸ‡¦ğŸ‡¹', 'ğŸ‡¦ğŸ‡¿', 'ğŸ‡§ğŸ‡¸', 'ğŸ‡§ğŸ‡­', 'ğŸ‡§ğŸ‡©', 'ğŸ‡§ğŸ‡§', 'ğŸ‡§ğŸ‡¾', 'ğŸ‡§ğŸ‡ª', 'ğŸ‡§ğŸ‡¿', 'ğŸ‡§ğŸ‡¯', 'ğŸ‡§ğŸ‡²', 'ğŸ‡§ğŸ‡¹', 'ğŸ‡§ğŸ‡´', 'ğŸ‡§ğŸ‡¦', 'ğŸ‡§ğŸ‡¼', 'ğŸ‡§ğŸ‡·', 'ğŸ‡®ğŸ‡´', 'ğŸ‡»ğŸ‡¬', 'ğŸ‡§ğŸ‡³', 'ğŸ‡§ğŸ‡¬', 'ğŸ‡§ğŸ‡«', 'ğŸ‡§ğŸ‡®', 'ğŸ‡°ğŸ‡­', 'ğŸ‡¨ğŸ‡²', 'ğŸ‡¨ğŸ‡¦', 'ğŸ‡®ğŸ‡¨', 'ğŸ‡¨ğŸ‡»', 'ğŸ‡§ğŸ‡¶', 'ğŸ‡°ğŸ‡¾', 'ğŸ‡¨ğŸ‡«', 'ğŸ‡¹ğŸ‡©', 'ğŸ‡¨ğŸ‡±', 'ğŸ‡¨ğŸ‡³', 'ğŸ‡¨ğŸ‡½', 'ğŸ‡¨ğŸ‡¨', 'ğŸ‡¨ğŸ‡´', 'ğŸ‡°ğŸ‡²', 'ğŸ‡¨ğŸ‡¬', 'ğŸ‡¨ğŸ‡©', 'ğŸ‡¨ğŸ‡°', 'ğŸ‡¨ğŸ‡·', 'ğŸ‡¨ğŸ‡®', 'ğŸ‡­ğŸ‡·', 'ğŸ‡¨ğŸ‡º', 'ğŸ‡¨ğŸ‡¼', 'ğŸ‡¨ğŸ‡¾', 'ğŸ‡¨ğŸ‡¿', 'ğŸ‡©ğŸ‡°', 'ğŸ‡©ğŸ‡¯', 'ğŸ‡©ğŸ‡²', 'ğŸ‡©ğŸ‡´', 'ğŸ‡ªğŸ‡¨', 'ğŸ‡ªğŸ‡¬', 'ğŸ‡¸ğŸ‡»', 'ğŸ‡¬ğŸ‡¶', 'ğŸ‡ªğŸ‡·', 'ğŸ‡ªğŸ‡ª', 'ğŸ‡¸ğŸ‡¿', 'ğŸ‡ªğŸ‡¹', 'ğŸ‡ªğŸ‡º', 'ğŸ‡«ğŸ‡°', 'ğŸ‡«ğŸ‡´', 'ğŸ‡«ğŸ‡¯', 'ğŸ‡«ğŸ‡®', 'ğŸ‡«ğŸ‡·', 'ğŸ‡¬ğŸ‡«', 'ğŸ‡µğŸ‡«', 'ğŸ‡¹ğŸ‡«', 'ğŸ‡¬ğŸ‡¦', 'ğŸ‡¬ğŸ‡²', 'ğŸ‡¬ğŸ‡ª', 'ğŸ‡©ğŸ‡ª', 'ğŸ‡¬ğŸ‡­', 'ğŸ‡¬ğŸ‡®', 'ğŸ‡¬ğŸ‡·', 'ğŸ‡¬ğŸ‡±', 'ğŸ‡¬ğŸ‡©', 'ğŸ‡¬ğŸ‡µ', 'ğŸ‡¬ğŸ‡º', 'ğŸ‡¬ğŸ‡¹', 'ğŸ‡¬ğŸ‡¬', 'ğŸ‡¬ğŸ‡³', 'ğŸ‡¬ğŸ‡¼', 'ğŸ‡¬ğŸ‡¾', 'ğŸ‡­ğŸ‡¹', 'ğŸ‡­ğŸ‡³', 'ğŸ‡­ğŸ‡°', 'ğŸ‡­ğŸ‡º', 'ğŸ‡®ğŸ‡¸', 'ğŸ‡®ğŸ‡³', 'ğŸ‡®ğŸ‡©', 'ğŸ‡®ğŸ‡·', 'ğŸ‡®ğŸ‡¶', 'ğŸ‡®ğŸ‡ª', 'ğŸ‡®ğŸ‡²', 'ğŸ‡®ğŸ‡±', 'ğŸ‡®ğŸ‡¹', 'ğŸ‡¯ğŸ‡²', 'ğŸ‡¯ğŸ‡µ', 'ğŸŒ', 'ğŸ‡¯ğŸ‡ª', 'ğŸ‡¯ğŸ‡´', 'ğŸ‡°ğŸ‡¿', 'ğŸ‡°ğŸ‡ª', 'ğŸ‡°ğŸ‡®', 'ğŸ‡½ğŸ‡°', 'ğŸ‡°ğŸ‡¼', 'ğŸ‡°ğŸ‡¬', 'ğŸ‡±ğŸ‡¦', 'ğŸ‡±ğŸ‡»', 'ğŸ‡±ğŸ‡§', 'ğŸ‡±ğŸ‡¸', 'ğŸ‡±ğŸ‡·', 'ğŸ‡±ğŸ‡¾', 'ğŸ‡±ğŸ‡®', 'ğŸ‡±ğŸ‡¹', 'ğŸ‡±ğŸ‡º', 'ğŸ‡²ğŸ‡´', 'ğŸ‡²ğŸ‡¬', 'ğŸ‡²ğŸ‡¼', 'ğŸ‡²ğŸ‡¾', 'ğŸ‡²ğŸ‡»', 'ğŸ‡²ğŸ‡±', 'ğŸ‡²ğŸ‡¹', 'ğŸ‡²ğŸ‡­', 'ğŸ‡²ğŸ‡¶', 'ğŸ‡²ğŸ‡·', 'ğŸ‡²ğŸ‡º', 'ğŸ‡¾ğŸ‡¹', 'ğŸ‡²ğŸ‡½', 'ğŸ‡«ğŸ‡²', 'ğŸ‡²ğŸ‡©', 'ğŸ‡²ğŸ‡¨', 'ğŸ‡²ğŸ‡³', 'ğŸ‡²ğŸ‡ª', 'ğŸ‡²ğŸ‡¸', 'ğŸ‡²ğŸ‡¦', 'ğŸ‡²ğŸ‡¿', 'ğŸ‡²ğŸ‡²', 'ğŸ‡³ğŸ‡¦', 'ğŸ‡³ğŸ‡·', 'ğŸ‡³ğŸ‡µ', 'ğŸ‡³ğŸ‡±', 'ğŸ‡³ğŸ‡¨', 'ğŸ‡³ğŸ‡¿', 'ğŸ‡³ğŸ‡®', 'ğŸ‡³ğŸ‡ª', 'ğŸ‡³ğŸ‡¬', 'ğŸ‡³ğŸ‡º', 'ğŸ‡³ğŸ‡«', 'ğŸ‡°ğŸ‡µ', 'ğŸ‡²ğŸ‡°', 'ğŸ‡²ğŸ‡µ', 'ğŸ‡³ğŸ‡´', 'ğŸ‡´ğŸ‡²', 'ğŸ‡µğŸ‡°', 'ğŸ‡µğŸ‡¼', 'ğŸ‡µğŸ‡¸', 'ğŸ‡µğŸ‡¦', 'ğŸ‡µğŸ‡¬', 'ğŸ‡µğŸ‡¾', 'ğŸ‡µğŸ‡ª', 'ğŸ‡µğŸ‡­', 'ğŸ‡µğŸ‡³', 'ğŸ‡µğŸ‡±', 'ğŸ‡µğŸ‡¹', 'ğŸ‡µğŸ‡·', 'ğŸ‡¶ğŸ‡¦', 'ğŸ‡·ğŸ‡ª', 'ğŸ‡·ğŸ‡´', 'ğŸ‡·ğŸ‡º', 'ğŸ‡·ğŸ‡¼', 'ğŸ‡¼ğŸ‡¸', 'ğŸ‡¸ğŸ‡²', 'ğŸ‡¸ğŸ‡¹', 'ğŸ‡¸ğŸ‡¦', 'ğŸ‡¸ğŸ‡³', 'ğŸ‡·ğŸ‡¸', 'ğŸ‡¸ğŸ‡¨', 'ğŸ‡¸ğŸ‡±', 'ğŸ‡¸ğŸ‡¬', 'ğŸ‡¸ğŸ‡½', 'ğŸ‡¸ğŸ‡°', 'ğŸ‡¸ğŸ‡®', 'ğŸ‡¬ğŸ‡¸', 'ğŸ‡¸ğŸ‡§', 'ğŸ‡¸ğŸ‡´', 'ğŸ‡¿ğŸ‡¦', 'ğŸ‡°ğŸ‡·', 'ğŸ‡¸ğŸ‡¸', 'ğŸ‡ªğŸ‡¸', 'ğŸ‡±ğŸ‡°', 'ğŸ‡§ğŸ‡±', 'ğŸ‡¸ğŸ‡­', 'ğŸ‡°ğŸ‡³', 'ğŸ‡±ğŸ‡¨', 'ğŸ‡µğŸ‡²', 'ğŸ‡»ğŸ‡¨', 'ğŸ‡¸ğŸ‡©', 'ğŸ‡¸ğŸ‡·', 'ğŸ‡¸ğŸ‡ª', 'ğŸ‡¨ğŸ‡­', 'ğŸ‡¸ğŸ‡¾', 'ğŸ‡¹ğŸ‡¼', 'ğŸ‡¹ğŸ‡¯', 'ğŸ‡¹ğŸ‡¿', 'ğŸ‡¹ğŸ‡­', 'ğŸ‡¹ğŸ‡±', 'ğŸ‡¹ğŸ‡¬', 'ğŸ‡¹ğŸ‡°', 'ğŸ‡¹ğŸ‡´', 'ğŸ‡¹ğŸ‡¹', 'ğŸ‡¹ğŸ‡³', 'ğŸ‡¹ğŸ‡·', 'ğŸ‡¹ğŸ‡²', 'ğŸ‡¹ğŸ‡¨', 'ğŸ‡¹ğŸ‡»', 'ğŸ‡»ğŸ‡®', 'ğŸ‡ºğŸ‡¬', 'ğŸ‡ºğŸ‡¦', 'ğŸ‡¦ğŸ‡ª', 'ğŸ‡¬ğŸ‡§', 'ğŸ´ó §ó ¢ó ¥ó ®ó §ó ¿', 'ğŸ´ó §ó ¢ó ³ó £ó ´ó ¿', 'ğŸ´ó §ó ¢ó ·ó ¬ó ³ó ¿', 'ğŸ‡ºğŸ‡¸', 'ğŸ‡ºğŸ‡¾', 'ğŸ‡ºğŸ‡¿', 'ğŸ‡»ğŸ‡º', 'ğŸ‡»ğŸ‡¦', 'ğŸ‡»ğŸ‡ª', 'ğŸ‡»ğŸ‡³', 'ğŸ‡¼ğŸ‡«', 'ğŸ‡ªğŸ‡­', 'ğŸ‡¾ğŸ‡ª', 'ğŸ‡¿ğŸ‡²', 'ğŸ‡¿ğŸ‡¼']
    }
};

function showEmojiPickerForInput() {
    const existingPicker = document.querySelector('.emoji-picker-full');
    if (existingPicker) {
        existingPicker.remove();
        return;
    }
    const picker = createFullEmojiPicker((emoji) => {
        const input = document.getElementById('messageInput');
        input.value += emoji;
        input.focus();
    });
    document.body.appendChild(picker);
}

function showEmojiPickerForMessage(messageId) {
    const existingPicker = document.querySelector('.emoji-picker-full');
    if (existingPicker) {
        existingPicker.remove();
        return;
    }
    const picker = createFullEmojiPicker((emoji) => {
        addReaction(messageId, emoji);
    });
    document.body.appendChild(picker);
}

function createFullEmojiPicker(onSelect) {
    const picker = document.createElement('div');
    picker.className = 'emoji-picker-full';

    const tabs = document.createElement('div');
    tabs.className = 'emoji-tabs';

    const content = document.createElement('div');
    content.className = 'emoji-content';

    const categoryKeys = Object.keys(EMOJI_CATEGORIES);

    categoryKeys.forEach((key, index) => {
        const category = EMOJI_CATEGORIES[key];
        const tab = document.createElement('button');
        tab.className = 'emoji-tab' + (index === 0 ? ' active' : '');
        tab.innerHTML = category.icon;
        tab.title = category.name;
        tab.addEventListener('click', () => {
            tabs.querySelectorAll('.emoji-tab').forEach(t => t.classList.remove('active'));
            tab.classList.add('active');
            renderCategory(key);
        });
        tabs.appendChild(tab);
    });

    function renderCategory(key) {
        const category = EMOJI_CATEGORIES[key];
        content.innerHTML = '';

        const title = document.createElement('div');
        title.className = 'emoji-category-title';
        title.textContent = category.name;
        content.appendChild(title);

        const grid = document.createElement('div');
        grid.className = 'emoji-grid';

        category.emojis.forEach(emoji => {
            const btn = document.createElement('button');
            btn.className = 'emoji-option';
            btn.innerHTML = emoji;
            btn.addEventListener('click', () => {
                onSelect(emoji);
                picker.remove();
            });
            grid.appendChild(btn);
        });

        content.appendChild(grid);

        if (typeof twemoji !== 'undefined') {
            twemoji.parse(content);
        }
    }

    if (typeof twemoji !== 'undefined') {
        twemoji.parse(tabs);
    }

    renderCategory(categoryKeys[0]);

    picker.appendChild(tabs);
    picker.appendChild(content);

    setTimeout(() => {
        document.addEventListener('click', function closePicker(e) {
            if (!picker.contains(e.target) && !e.target.closest('.emoji-btn') && !e.target.closest('.add-reaction-btn')) {
                picker.remove();
                document.removeEventListener('click', closePicker);
            }
        });
    }, 100);

    return picker;
}

function addReaction(messageId, emoji) {
    // Ğ•ÑĞ»Ğ¸ ÑÑ‚Ğ¾ Self Chat, Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ°Ñ‚Ñ‹Ğ²Ğ°ĞµĞ¼ Ğ»Ğ¾ĞºĞ°Ğ»ÑŒĞ½Ğ¾
    if (currentDMUserId === currentUser.id) {
        addSelfChatReaction(messageId, emoji);
    } else if (socket && socket.connected) {
        socket.emit('add-reaction', { messageId, emoji });
    }
}

function updateMessageReactions(messageId, reactions) {
    const reactionsContainer = document.querySelector(`[data-message-id="${messageId}"] .message-reactions`);
    if (!reactionsContainer) return;

    reactionsContainer.innerHTML = '';

    reactions.forEach(reaction => {
        const reactionEl = document.createElement('div');
        reactionEl.className = 'reaction';
        reactionEl.innerHTML = `${reaction.emoji} <span>${reaction.count}</span>`;
        reactionEl.title = reaction.users;

        // Ğ”Ğ»Ñ Self Chat Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ñ€ĞµĞ°ĞºÑ†Ğ¸Ğ¹ Ğ±ÑƒĞ´ĞµÑ‚ Ğ¾Ñ‚Ğ»Ğ¸Ñ‡Ğ°Ñ‚ÑŒÑÑ
        if (currentDMUserId === currentUser.id) {
            // Ğ’ Self Chat Ğ¿Ñ€Ğ¾ÑÑ‚Ğ¾ ÑƒĞ´Ğ°Ğ»ÑĞµĞ¼ Ñ€ĞµĞ°ĞºÑ†Ğ¸Ñ Ğ¿Ñ€Ğ¸ ĞºĞ»Ğ¸ĞºĞµ
            reactionEl.addEventListener('click', () => {
                removeSelfChatReaction(messageId, reaction.emoji);
            });
        } else {
            // Ğ”Ğ»Ñ Ğ¾Ğ±Ñ‹Ñ‡Ğ½Ñ‹Ñ… DM Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ Ñ‡ĞµÑ€ĞµĞ· ÑĞ¾ĞºĞµÑ‚
            reactionEl.addEventListener('click', () => {
                if (socket && socket.connected) {
                    socket.emit('remove-reaction', { messageId, emoji: reaction.emoji });
                }
            });
        }
        reactionsContainer.appendChild(reactionEl);
    });

    if (typeof twemoji !== 'undefined') {
        twemoji.parse(reactionsContainer);
    }
}

// Ğ¤ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ´Ğ»Ñ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ Ñ€ĞµĞ°ĞºÑ†Ğ¸Ğ¸ Ğ² Self Chat
function addSelfChatReaction(messageId, emoji) {
    const key = `selfChatHistory_${currentUser.id}`;
    const history = JSON.parse(localStorage.getItem(key)) || [];

    const messageIndex = history.findIndex(msg => msg.id === messageId);
    if (messageIndex !== -1) {
        const message = history[messageIndex];
        if (!message.reactions) {
            message.reactions = [];
        }

        // ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼, ĞµÑÑ‚ÑŒ Ğ»Ğ¸ ÑƒĞ¶Ğµ Ñ‚Ğ°ĞºĞ°Ñ Ñ€ĞµĞ°ĞºÑ†Ğ¸Ñ
        const existingReaction = message.reactions.find(r => r.emoji === emoji);
        if (existingReaction) {
            existingReaction.count++;
        } else {
            message.reactions.push({
                emoji: emoji,
                count: 1,
                users: [currentUser.username]
            });
        }

        // ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ Ğ¸ÑÑ‚Ğ¾Ñ€Ğ¸Ñ
        localStorage.setItem(key, JSON.stringify(history));

        // ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ Ğ¾Ñ‚Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ
        updateSelfChatMessage(messageId, message);
    }
}

// Ğ¤ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ´Ğ»Ñ ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¸Ñ Ñ€ĞµĞ°ĞºÑ†Ğ¸Ğ¸ Ğ¸Ğ· Self Chat
function removeSelfChatReaction(messageId, emoji) {
    const key = `selfChatHistory_${currentUser.id}`;
    const history = JSON.parse(localStorage.getItem(key)) || [];

    const messageIndex = history.findIndex(msg => msg.id === messageId);
    if (messageIndex !== -1) {
        const message = history[messageIndex];
        if (message.reactions) {
            const reactionIndex = message.reactions.findIndex(r => r.emoji === emoji);
            if (reactionIndex !== -1) {
                const reaction = message.reactions[reactionIndex];
                reaction.count--;

                // Ğ•ÑĞ»Ğ¸ ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ñ€ĞµĞ°ĞºÑ†Ğ¸Ğ¹ ÑÑ‚Ğ°Ğ»Ğ¾ 0, ÑƒĞ´Ğ°Ğ»ÑĞµĞ¼ Ñ€ĞµĞ°ĞºÑ†Ğ¸Ñ
                if (reaction.count <= 0) {
                    message.reactions.splice(reactionIndex, 1);
                }
            }
        }

        // ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ Ğ¸ÑÑ‚Ğ¾Ñ€Ğ¸Ñ
        localStorage.setItem(key, JSON.stringify(history));

        // ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ Ğ¾Ñ‚Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ
        updateSelfChatMessage(messageId, message);
    }
}

// Ğ¤ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ´Ğ»Ñ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ñ Ğ¾Ñ‚Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ñ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ Ğ² Self Chat
function updateSelfChatMessage(messageId, updatedMessage) {
    const messageElement = document.querySelector(`[data-message-id="${messageId}"]`);
    if (messageElement) {
        messageElement.remove(); // Ğ£Ğ´Ğ°Ğ»ÑĞµĞ¼ ÑÑ‚Ğ°Ñ€Ğ¾Ğµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ

        // Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ½Ğ¾Ğµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ
        addMessageToUI(updatedMessage);
    }
}

// File upload
function initializeFileUpload() {
    const attachBtn = document.querySelector('.attach-btn');
    if (!attachBtn) {
        console.error('Attach button element not found');
        return;
    }

    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.style.display = 'none';
    document.body.appendChild(fileInput);

    attachBtn.addEventListener('click', () => {
        fileInput.click();
    });

    fileInput.addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (file) {
            await uploadFile(file);
        }
        fileInput.value = '';
    });
}

async function uploadFile(file) {
    try {
        const formData = new FormData();
        formData.append('file', file);
        formData.append('dmId', currentDMUserId); // Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ ID Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ°Ñ‚ĞµĞ»Ñ Ğ´Ğ»Ñ DM
        formData.append('senderId', currentUser.id); // Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ ID Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚ĞµĞ»Ñ

        const response = await fetch(`${getApiUrl()}/api/upload`, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${token}`
            },
            body: formData
        });

        if (!response.ok) {
            throw new Error('Upload failed');
        }

        const fileData = await response.json();

        const message = {
            id: Date.now(), // Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½ÑƒÑ Ğ¼ĞµÑ‚ĞºÑƒ ĞºĞ°Ğº ID
            author: currentUser.username,
            avatar: currentUser.avatar,
            text: '', // Ğ£Ğ±Ğ¸Ñ€Ğ°ĞµĞ¼ Ñ‚ĞµĞºÑÑ‚ "Uploaded [filename]"
            file: fileData,
            timestamp: new Date(),
            reactions: []
        };

        // Ğ•ÑĞ»Ğ¸ ÑÑ‚Ğ¾ Self Chat, ÑĞ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ»Ğ¾ĞºĞ°Ğ»ÑŒĞ½Ğ¾
        if (currentDMUserId === currentUser.id) {
            addMessageToUI(message);
            saveSelfMessageToHistory(message);
            scrollToBottom();
        } else if (currentDMUserId) {
            // Ğ”Ğ»Ñ Ğ¾Ğ±Ñ‹Ñ‡Ğ½Ñ‹Ñ… DM Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ Ñ‡ĞµÑ€ĞµĞ· ÑĞ¾ĞºĞµÑ‚
            if (socket && socket.connected) {
                socket.emit('send-dm', {
                    receiverId: currentDMUserId,
                    message: message
                });
            }
        }

    } catch (error) {
        console.error('Upload error:', error);
        alert('Failed to upload file');
    }
}

// User controls
function initializeUserControls() {
    const muteBtn = document.getElementById('muteBtn');
    const deafenBtn = document.getElementById('deafenBtn');
    const settingsBtn = document.getElementById('settingsBtn');

    if (muteBtn) {
        muteBtn.addEventListener('click', () => {
            isMuted = !isMuted;
            const normalIcon = muteBtn.querySelector('.icon-normal');
            const slashedIcon = muteBtn.querySelector('.icon-slashed');

            if (normalIcon) normalIcon.style.display = isMuted ? 'none' : 'block';
            if (slashedIcon) slashedIcon.style.display = isMuted ? 'block' : 'none';

            if (localStream) {
                localStream.getAudioTracks().forEach(track => {
                    track.enabled = !isMuted;
                });
            }
        });
    }

    if (deafenBtn) {
        deafenBtn.addEventListener('click', () => {
            isDeafened = !isDeafened;
            const normalIcon = deafenBtn.querySelector('.icon-normal');
            const slashedIcon = deafenBtn.querySelector('.icon-slashed');

            if (normalIcon) normalIcon.style.display = isDeafened ? 'none' : 'block';
            if (slashedIcon) slashedIcon.style.display = isDeafened ? 'block' : 'none';

            // When deafened, also mute microphone
            if (isDeafened) {
                if (!isMuted) {
                    isMuted = true;
                    if (muteBtn) {
                        const normalIcon = muteBtn.querySelector('.icon-normal');
                        const slashedIcon = muteBtn.querySelector('.icon-slashed');

                        if (normalIcon) normalIcon.style.display = 'none';
                        if (slashedIcon) slashedIcon.style.display = 'block';
                    }
                }

                // Mute all remote audio
                document.querySelectorAll('video[id^="remote-"]').forEach(video => {
                    video.volume = 0;
                });
            } else {
                // Unmute remote audio
                document.querySelectorAll('video[id^="remote-"]').forEach(video => {
                    video.volume = 1;
                });
            }

            // Update local stream audio tracks
            if (localStream) {
                localStream.getAudioTracks().forEach(track => {
                    track.enabled = !isMuted;
                });
            }
        });
    }

    if (settingsBtn) {
        settingsBtn.addEventListener('click', () => {
            if (confirm('Do you want to logout?')) {
                if (inCall) leaveVoiceChannel();
                localStorage.removeItem('token');
                localStorage.removeItem('currentUser');
                if (socket) socket.disconnect();
                window.location.replace('login.html');
            }
        });
    }
}

// Voice channel functions - call persists when switching views

async function initializeMedia() {
    try {
        // Better audio constraints for clear voice
        const constraints = {
            video: {
                width: { ideal: 1280 },
                height: { ideal: 720 }
            },
            audio: {
                echoCancellation: true,
                noiseSuppression: true,
                autoGainControl: true,
                sampleRate: 48000,
                sampleSize: 16,
                channelCount: 1
            }
        };
        
        localStream = await navigator.mediaDevices.getUserMedia(constraints);
        
        const localVideo = document.getElementById('localVideo');
        localVideo.srcObject = localStream;
        
        // Log audio track status
        const audioTracks = localStream.getAudioTracks();
        console.log('Local audio tracks:', audioTracks.length);
        audioTracks.forEach(track => {
            console.log(`Audio track: ${track.label}, enabled: ${track.enabled}, readyState: ${track.readyState}`);
        });
        
        if (isMuted || isDeafened) {
            audioTracks.forEach(track => {
                track.enabled = false;
            });
        }
    } catch (error) {
        console.error('Error getting media devices:', error);
        throw error;
    }
}


function initializeCallControls() {
    const closeCallBtn = document.getElementById('closeCallBtn');
    const toggleVideoBtn = document.getElementById('toggleVideoBtn');
    const toggleAudioBtn = document.getElementById('toggleAudioBtn');
    const toggleScreenBtn = document.getElementById('toggleScreenBtn');

    if (closeCallBtn) {
        closeCallBtn.addEventListener('click', () => {
            // End call for direct calls
            if (window.currentCallDetails) {
                // End a direct call
                Object.keys(peerConnections).forEach(socketId => {
                    if (socket && socket.connected) {
                        socket.emit('end-call', { to: socketId });
                    }
                });
            }
        });
    }

    if (toggleVideoBtn) {
        toggleVideoBtn.addEventListener('click', () => {
            toggleVideo();
        });
    }

    if (toggleAudioBtn) {
        toggleAudioBtn.addEventListener('click', () => {
            toggleAudio();
        });
    }

    if (toggleScreenBtn) {
        toggleScreenBtn.addEventListener('click', () => {
            toggleScreenShare();
        });
    }
}

function toggleVideo() {
    if (!localStream) return;
    
    isVideoEnabled = !isVideoEnabled;
    localStream.getVideoTracks().forEach(track => {
        track.enabled = isVideoEnabled;
    });
    
    // Notify peer about video state change
    Object.keys(peerConnections).forEach(socketId => {
        if (socket && socket.connected) {
            socket.emit('video-toggle', {
                to: socketId,
                enabled: isVideoEnabled
            });
        }
    });
    
    updateCallButtons();
}

function toggleAudio() {
    if (!localStream) return;
    
    isAudioEnabled = !isAudioEnabled;
    localStream.getAudioTracks().forEach(track => {
        track.enabled = isAudioEnabled;
    });
    
    if (!isAudioEnabled) {
        isMuted = true;
        document.getElementById('muteBtn').classList.add('active');
    } else {
        isMuted = false;
        document.getElementById('muteBtn').classList.remove('active');
    }
    
    updateCallButtons();
}

async function toggleScreenShare() {
    if (screenStream) {
        // Stop screen sharing
        screenStream.getTracks().forEach(track => track.stop());
        
        // Replace screen track with camera track in all peer connections
        const videoTrack = localStream.getVideoTracks()[0];
        Object.values(peerConnections).forEach(pc => {
            const sender = pc.getSenders().find(s => s.track && s.track.kind === 'video');
            if (sender && videoTrack) {
                sender.replaceTrack(videoTrack);
            }
        });
        
        screenStream = null;
        
        const localVideo = document.getElementById('localVideo');
        localVideo.srcObject = localStream;
        
        updateCallButtons();
    } else {
        try {
            // Start screen sharing
            screenStream = await navigator.mediaDevices.getDisplayMedia({
                video: {
                    cursor: 'always',
                    width: { ideal: 1920 },
                    height: { ideal: 1080 }
                },
                audio: {
                    echoCancellation: true,
                    noiseSuppression: true,
                    sampleRate: 44100
                }
            });
            
            const screenTrack = screenStream.getVideoTracks()[0];
            
            // Replace video track in all peer connections
            Object.values(peerConnections).forEach(pc => {
                const sender = pc.getSenders().find(s => s.track && s.track.kind === 'video');
                if (sender) {
                    sender.replaceTrack(screenTrack);
                }
            });
            
            // Show screen share in local video
            const localVideo = document.getElementById('localVideo');
            const mixedStream = new MediaStream([
                screenTrack,
                ...localStream.getAudioTracks()
            ]);
            localVideo.srcObject = mixedStream;
            
            // Handle screen share ending
            screenTrack.addEventListener('ended', () => {
                toggleScreenShare(); // This will stop screen sharing
            });
            
            updateCallButtons();
        } catch (error) {
            console.error('Error sharing screen:', error);
            if (error.name === 'NotAllowedError') {
                alert('Screen sharing permission denied');
            } else {
                alert('Error sharing screen. Please try again.');
            }
        }
    }
}

function updateCallButtons() {
    const toggleVideoBtn = document.getElementById('toggleVideoBtn');
    const toggleAudioBtn = document.getElementById('toggleAudioBtn');
    const toggleScreenBtn = document.getElementById('toggleScreenBtn');

    if (toggleVideoBtn) {
        toggleVideoBtn.classList.toggle('active', !isVideoEnabled);
    }

    if (toggleAudioBtn) {
        toggleAudioBtn.classList.toggle('active', !isAudioEnabled);
    }

    if (toggleScreenBtn) {
        toggleScreenBtn.classList.toggle('active', screenStream !== null);
    }
}

function initializeDraggableCallWindow() {
   const callInterface = document.getElementById('callInterface');

   if (!callInterface) {
       console.error('Call interface element not found');
       return;
   }

   const callHeader = callInterface.querySelector('.call-header');

   if (!callHeader) {
       console.error('Call header element not found');
       return;
   }

   let isDragging = false;
   let offsetX, offsetY;

   callHeader.addEventListener('mousedown', (e) => {
       isDragging = true;
       offsetX = e.clientX - callInterface.offsetLeft;
       offsetY = e.clientY - callInterface.offsetTop;
       callInterface.style.transition = 'none'; // Disable transition during drag
   });

   document.addEventListener('mousemove', (e) => {
       if (isDragging) {
           let newX = e.clientX - offsetX;
           let newY = e.clientY - offsetY;

           // Constrain within viewport
           const maxX = window.innerWidth - callInterface.offsetWidth;
           const maxY = window.innerHeight - callInterface.offsetHeight;

           newX = Math.max(0, Math.min(newX, maxX));
           newY = Math.max(0, Math.min(newY, maxY));

           callInterface.style.left = `${newX}px`;
           callInterface.style.top = `${newY}px`;
       }
   });

   document.addEventListener('mouseup', () => {
       if (isDragging) {
           isDragging = false;
           callInterface.style.transition = 'all 0.3s ease'; // Re-enable transition
       }
   });
}

async function loadDMHistory(userId) {
   // ĞĞµ Ğ·Ğ°Ğ³Ñ€ÑƒĞ¶Ğ°ĞµĞ¼ Ğ¸ÑÑ‚Ğ¾Ñ€Ğ¸Ñ Ğ´Ğ»Ñ Self Chat, Ñ‚Ğ°Ğº ĞºĞ°Ğº Ğ¾Ğ½Ğ° Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑÑ Ğ»Ğ¾ĞºĞ°Ğ»ÑŒĞ½Ğ¾
   if (userId === currentUser.id) {
       return;
   }

   const messagesContainer = document.getElementById('messagesContainer');

   if (!messagesContainer) {
       console.error('Messages container element not found');
       return;
   }

   messagesContainer.innerHTML = '';

   try {
       const response = await fetch(`${getApiUrl()}/api/dm/${userId}?t=${Date.now()}`, {
           headers: { 'Authorization': `Bearer ${token}` },
           cache: 'no-cache'
       });
       if (response.ok) {
           const messages = await response.json();
           messages.forEach(message => {
               addMessageToUI({
                   id: message.id,
                   author: message.username,
                   avatar: message.avatar || message.username.charAt(0).toUpperCase(),
                   text: message.content,
                   timestamp: message.created_at,
                   reactions: message.reactions || [],
                   file: message.file  // Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾ Ñ„Ğ°Ğ¹Ğ»Ğµ, ĞµÑĞ»Ğ¸ Ğ¾Ğ½Ğ° ĞµÑÑ‚ÑŒ
               });
           });
       } else {
           console.error('Failed to load DM history');
       }
   } catch (error) {
       console.error('Error loading DM history:', error);
   }

   scrollToBottom();
}

console.log('Discord Clone initialized successfully!');
if (currentUser) {
   console.log('Logged in as:', currentUser.username);
}

function populateDMList(friends) {
   const dmList = document.getElementById('dmList');

   if (!dmList) {
       console.error('DM list element not found');
       return;
   }

   dmList.innerHTML = '';

   // Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ñ‡Ğ°Ñ‚ Ñ ÑĞ°Ğ¼Ğ¸Ğ¼ ÑĞ¾Ğ±Ğ¾Ğ¹ Ğ² Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ¾ ÑĞ¿Ğ¸ÑĞºĞ°
   const selfChatItem = document.createElement('div');
   selfChatItem.className = 'channel';
   selfChatItem.setAttribute('data-dm-id', 'self');
   selfChatItem.innerHTML = `
       <div class="friend-avatar self-chat-icon">${currentUser.avatar || currentUser.username.charAt(0).toUpperCase()}</div>
       <span>Self Chat</span>
   `;
   selfChatItem.addEventListener('click', () => {
       startSelfChat();
   });
   dmList.appendChild(selfChatItem);

   if (friends.length === 0) {
       const emptyDM = document.createElement('div');
       emptyDM.className = 'empty-dm-list';
       emptyDM.textContent = 'No conversations yet.';
       dmList.appendChild(emptyDM);
       return;
   }

   friends.forEach(friend => {
       const dmItem = document.createElement('div');
       dmItem.className = 'channel';
       dmItem.setAttribute('data-dm-id', friend.id);
       dmItem.innerHTML = `
           <div class="friend-avatar">${friend.avatar || friend.username.charAt(0).toUpperCase()}</div>
           <span>${friend.username}</span>
       `;
       dmItem.addEventListener('click', () => {
           startDM(friend.id, friend.username);
       });
       dmList.appendChild(dmItem);
   });
}

// WebRTC Functions
function createPeerConnection(remoteSocketId, isInitiator) {
    console.log(`Creating peer connection with ${remoteSocketId}, initiator: ${isInitiator}`);
    
    if (peerConnections[remoteSocketId]) {
        console.log('Peer connection already exists');
        return peerConnections[remoteSocketId];
    }
    
    const pc = new RTCPeerConnection({
        iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' },
            { urls: 'stun:stun2.l.google.com:19302' },
            { urls: 'stun:stun3.l.google.com:19302' },
            { urls: 'stun:stun4.l.google.com:19302' }
        ],
        iceCandidatePoolSize: 10
    });

    peerConnections[remoteSocketId] = pc;

    // Add local stream tracks with better error handling
    if (localStream) {
        const audioTracks = localStream.getAudioTracks();
        const videoTracks = localStream.getVideoTracks();
        
        console.log(`Adding tracks - Audio: ${audioTracks.length}, Video: ${videoTracks.length}`);
        
        // Add audio tracks first (priority for voice calls)
        audioTracks.forEach(track => {
            console.log(`Adding audio track: ${track.label}, enabled: ${track.enabled}`);
            pc.addTrack(track, localStream);
        });
        
        // Then add video tracks
        videoTracks.forEach(track => {
            console.log(`Adding video track: ${track.label}, enabled: ${track.enabled}`);
            pc.addTrack(track, localStream);
        });
    } else {
        console.error('No local stream available');
    }

    // Handle ICE candidates
    pc.onicecandidate = (event) => {
        if (event.candidate) {
            console.log('Sending ICE candidate');
            socket.emit('ice-candidate', {
                to: remoteSocketId,
                candidate: event.candidate
            });
        }
    };
    
    // Handle connection state changes
    pc.oniceconnectionstatechange = () => {
        console.log(`ICE connection state: ${pc.iceConnectionState}`);
        if (pc.iceConnectionState === 'failed') {
            console.error('ICE connection failed');
            // Try to restart ICE
            pc.restartIce();
        }
        if (pc.iceConnectionState === 'connected') {
            console.log('Peer connection established successfully!');
        }
    };

    // Handle incoming remote stream
    pc.ontrack = (event) => {
        console.log('Received remote track:', event.track.kind, 'Stream ID:', event.streams[0]?.id);
        
        const remoteParticipants = document.getElementById('remoteParticipants');
        
        let participantDiv = document.getElementById(`participant-${remoteSocketId}`);
        let remoteVideo = document.getElementById(`remote-${remoteSocketId}`);
        
        if (!participantDiv) {
            participantDiv = document.createElement('div');
            participantDiv.className = 'participant';
            participantDiv.id = `participant-${remoteSocketId}`;
            
            remoteVideo = document.createElement('video');
            remoteVideo.id = `remote-${remoteSocketId}`;
            remoteVideo.autoplay = true;
            remoteVideo.playsInline = true;
            remoteVideo.volume = isDeafened ? 0 : 1; // Respect deafened state
            
            const participantName = document.createElement('div');
            participantName.className = 'participant-name';
            participantName.textContent = 'Friend';
            
            participantDiv.appendChild(remoteVideo);
            participantDiv.appendChild(participantName);
            remoteParticipants.appendChild(participantDiv);
        }
        
        // Set the stream to the video element
        if (event.streams && event.streams[0]) {
            console.log('Setting remote stream to video element');
            remoteVideo = document.getElementById(`remote-${remoteSocketId}`);
            if (remoteVideo) {
                remoteVideo.srcObject = event.streams[0];
                
                // Ensure audio is playing
                remoteVideo.play().catch(e => {
                    console.error('Error playing remote video:', e);
                    // Try to play after user interaction
                    document.addEventListener('click', () => {
                        remoteVideo.play().catch(err => console.error('Still cannot play:', err));
                    }, { once: true });
                });
            }
        }
        
        // Initialize resizable videos
        function initializeResizableVideos() {
            const callInterface = document.getElementById('callInterface');
            const participants = callInterface.querySelectorAll('.participant');
            
            participants.forEach(participant => {
                makeResizable(participant);
            });
            
            // Make call interface resizable too
            makeInterfaceResizable(callInterface);
        }
        
        // Make individual video resizable
        function makeResizable(element) {
            // Add resize handle
            const resizeHandle = document.createElement('div');
            resizeHandle.className = 'resize-handle';
            resizeHandle.innerHTML = 'â†˜';
            resizeHandle.style.cssText = `
                position: absolute;
                bottom: 5px;
                right: 5px;
                width: 20px;
                height: 20px;
                background: rgba(255,255,255,0.3);
                cursor: nwse-resize;
                display: flex;
                align-items: center;
                justify-content: center;
                border-radius: 3px;
                font-size: 12px;
                color: white;
                user-select: none;
            `;
            
            // Add video size controls
            const sizeControls = document.createElement('div');
            sizeControls.className = 'video-size-controls';
            sizeControls.innerHTML = `
                <button class="size-control-btn minimize-btn" title="Minimize">_</button>
                <button class="size-control-btn maximize-btn" title="Maximize">â–¡</button>
                <button class="size-control-btn fullscreen-btn" title="Fullscreen">â›¶</button>
            `;
            
            if (!element.querySelector('.resize-handle')) {
                element.appendChild(resizeHandle);
                element.appendChild(sizeControls);
                element.style.resize = 'both';
                element.style.overflow = 'auto';
                element.style.minWidth = '150px';
                element.style.minHeight = '100px';
                element.style.maxWidth = '90vw';
                element.style.maxHeight = '90vh';
                element.setAttribute('data-resizable', 'true');
                
                // Add double-click for fullscreen
                element.addEventListener('dblclick', function(e) {
                    if (!e.target.closest('.video-size-controls')) {
                        toggleVideoFullscreen(element);
                    }
                });
                
                // Size control buttons
                const minimizeBtn = sizeControls.querySelector('.minimize-btn');
                const maximizeBtn = sizeControls.querySelector('.maximize-btn');
                const fullscreenBtn = sizeControls.querySelector('.fullscreen-btn');
                
                minimizeBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    element.classList.toggle('minimized');
                    element.classList.remove('maximized');
                });
                
                maximizeBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    element.classList.toggle('maximized');
                    element.classList.remove('minimized');
                });
                
                fullscreenBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const video = element.querySelector('video');
                    if (video && video.requestFullscreen) {
                        video.requestFullscreen();
                    }
                });
            }
        }
        
        // Toggle video fullscreen
        function toggleVideoFullscreen(element) {
            element.classList.toggle('maximized');
            if (element.classList.contains('maximized')) {
                element.classList.remove('minimized');
            }
        }
        
        // Make call interface resizable
        function makeInterfaceResizable(callInterface) {
            const resizeHandle = document.createElement('div');
            resizeHandle.className = 'interface-resize-handle';
            resizeHandle.style.cssText = `
                position: absolute;
                bottom: 0;
                right: 0;
                width: 15px;
                height: 15px;
                cursor: nwse-resize;
                background: linear-gradient(135deg, transparent 50%, #5865f2 50%);
                border-bottom-right-radius: 12px;
            `;
            
            if (!callInterface.querySelector('.interface-resize-handle')) {
                callInterface.appendChild(resizeHandle);
                
                let isResizing = false;
                let startWidth = 0;
                let startHeight = 0;
                let startX = 0;
                let startY = 0;
                
                resizeHandle.addEventListener('mousedown', (e) => {
                    isResizing = true;
                    startWidth = parseInt(document.defaultView.getComputedStyle(callInterface).width, 10);
                    startHeight = parseInt(document.defaultView.getComputedStyle(callInterface).height, 10);
                    startX = e.clientX;
                    startY = e.clientY;
                    e.preventDefault();
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (!isResizing) return;
                    
                    const newWidth = startWidth + e.clientX - startX;
                    const newHeight = startHeight + e.clientY - startY;
                    
                    if (newWidth > 300 && newWidth < window.innerWidth * 0.9) {
                        callInterface.style.width = newWidth + 'px';
                    }
                    if (newHeight > 200 && newHeight < window.innerHeight * 0.9) {
                        callInterface.style.height = newHeight + 'px';
                    }
                });
                
                document.addEventListener('mouseup', () => {
                    isResizing = false;
                });
            }
        }
        
        // Update resizable functionality when new participants join
        const originalOntrack = RTCPeerConnection.prototype.ontrack;
        window.observeNewParticipants = function() {
            setTimeout(() => {
                const participants = document.querySelectorAll('.participant:not([data-resizable])');
                participants.forEach(participant => {
                    participant.setAttribute('data-resizable', 'true');
                    makeResizable(participant);
                });
            }, 500);
        };
        
        // Make the new participant video resizable after a short delay
        setTimeout(() => {
            if (typeof makeResizable === 'function' && participantDiv) {
                makeResizable(participantDiv);
            }
        }, 100);
    };

    // Create offer if initiator with modern constraints
    if (isInitiator) {
        pc.createOffer()
        .then(offer => {
            console.log('Created offer with SDP:', offer.sdp.substring(0, 200));
            return pc.setLocalDescription(offer);
        })
        .then(() => {
            console.log('Sending offer to:', remoteSocketId);
            socket.emit('offer', {
                to: remoteSocketId,
                offer: pc.localDescription
            });
        })
        .catch(error => {
            console.error('Error creating offer:', error);
        });
    }
    
    return pc;
}

// Initialize resizable videos
function initializeResizableVideos() {
    const callInterface = document.getElementById('callInterface');
    if (!callInterface) return;
    
    const participants = callInterface.querySelectorAll('.participant');
    participants.forEach(participant => {
        makeResizable(participant);
    });
    
    // Make call interface resizable too
    makeInterfaceResizable(callInterface);
}

// Make individual video resizable
function makeResizable(element) {
    if (!element || element.hasAttribute('data-resizable')) return;
    
    // Add resize handle
    const resizeHandle = document.createElement('div');
    resizeHandle.className = 'resize-handle';
    resizeHandle.innerHTML = 'â†˜';
    resizeHandle.style.cssText = `
        position: absolute;
        bottom: 5px;
        right: 5px;
        width: 20px;
        height: 20px;
        background: rgba(255,255,255,0.3);
        cursor: nwse-resize;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 3px;
        font-size: 12px;
        color: white;
        user-select: none;
        z-index: 10;
    `;
    
    // Add video size controls
    const sizeControls = document.createElement('div');
    sizeControls.className = 'video-size-controls';
    sizeControls.innerHTML = `
        <button class="size-control-btn minimize-btn" title="Minimize">_</button>
        <button class="size-control-btn maximize-btn" title="Maximize">â–¡</button>
        <button class="size-control-btn fullscreen-btn" title="Fullscreen">â›¶</button>
    `;
    sizeControls.style.cssText = `
        position: absolute;
        top: 8px;
        right: 8px;
        display: flex;
        gap: 4px;
        opacity: 0;
        transition: opacity 0.3s ease;
        z-index: 10;
    `;
    
    element.appendChild(resizeHandle);
    element.appendChild(sizeControls);
    element.style.resize = 'both';
    element.style.overflow = 'auto';
    element.style.minWidth = '150px';
    element.style.minHeight = '100px';
    element.style.maxWidth = '90vw';
    element.style.maxHeight = '90vh';
    element.setAttribute('data-resizable', 'true');
    
    // Show controls on hover
    element.addEventListener('mouseenter', () => {
        sizeControls.style.opacity = '1';
    });
    
    element.addEventListener('mouseleave', () => {
        sizeControls.style.opacity = '0';
    });
    
    // Add double-click for fullscreen
    element.addEventListener('dblclick', function(e) {
        if (!e.target.closest('.video-size-controls')) {
            toggleVideoFullscreen(element);
        }
    });
    
    // Size control buttons
    const minimizeBtn = sizeControls.querySelector('.minimize-btn');
    const maximizeBtn = sizeControls.querySelector('.maximize-btn');
    const fullscreenBtn = sizeControls.querySelector('.fullscreen-btn');
    
    if (minimizeBtn) {
        minimizeBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            element.classList.toggle('minimized');
            element.classList.remove('maximized');
        });
    }
    
    if (maximizeBtn) {
        maximizeBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            element.classList.toggle('maximized');
            element.classList.remove('minimized');
        });
    }
    
    if (fullscreenBtn) {
        fullscreenBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            const video = element.querySelector('video');
            if (video && video.requestFullscreen) {
                video.requestFullscreen();
            }
        });
    }
}

// Toggle video fullscreen
function toggleVideoFullscreen(element) {
    element.classList.toggle('maximized');
    if (element.classList.contains('maximized')) {
        element.classList.remove('minimized');
    }
}

// Make interface resizable
function makeInterfaceResizable(callInterface) {
    if (!callInterface || callInterface.hasAttribute('data-interface-resizable')) return;
    
    const resizeHandle = document.createElement('div');
    resizeHandle.className = 'interface-resize-handle';
    resizeHandle.style.cssText = `
        position: absolute;
        bottom: 0;
        right: 0;
        width: 15px;
        height: 15px;
        cursor: nwse-resize;
        background: linear-gradient(135deg, transparent 50%, #5865f2 50%);
        border-bottom-right-radius: 12px;
    `;
    
    callInterface.appendChild(resizeHandle);
    callInterface.setAttribute('data-interface-resizable', 'true');
    
    let isResizing = false;
    let startWidth = 0;
    let startHeight = 0;
    let startX = 0;
    let startY = 0;
    
    resizeHandle.addEventListener('mousedown', (e) => {
        isResizing = true;
        startWidth = parseInt(document.defaultView.getComputedStyle(callInterface).width, 10);
        startHeight = parseInt(document.defaultView.getComputedStyle(callInterface).height, 10);
        startX = e.clientX;
        startY = e.clientY;
        e.preventDefault();
    });
    
    document.addEventListener('mousemove', (e) => {
        if (!isResizing) return;
        
        const newWidth = startWidth + e.clientX - startX;
        const newHeight = startHeight + e.clientY - startY;
        
        if (newWidth > 400 && newWidth < window.innerWidth * 0.9) {
            callInterface.style.width = newWidth + 'px';
        }
        if (newHeight > 300 && newHeight < window.innerHeight * 0.9) {
            callInterface.style.height = newHeight + 'px';
        }
    });
    
    document.addEventListener('mouseup', () => {
        isResizing = false;
    });
}



// =======================================================
// Mobile drawer: open/close channel list
// =======================================================
(() => {
  const panel = document.getElementById("channelList");
  const overlay = document.getElementById("drawerOverlay");
  const btn = document.getElementById("mobileMenuBtn");

  if (!panel || !overlay || !btn) return;

  const isMobile = () => window.matchMedia("(max-width: 820px)").matches;

  const openDrawer = () => {
    if (!isMobile()) return;
    panel.classList.add("is-open");
    overlay.classList.add("is-open");
  };

  const closeDrawer = () => {
    panel.classList.remove("is-open");
    overlay.classList.remove("is-open");
  };

  btn.addEventListener("click", () => {
    const opened = panel.classList.contains("is-open");
    if (opened) closeDrawer();
    else openDrawer();
  });

  overlay.addEventListener("click", closeDrawer);

  // Close drawer when user selects a channel/DM item
  panel.addEventListener("click", (e) => {
    const target = e.target;
    if (!target) return;
    const channelEl = target.closest(".channel");
    if (channelEl && isMobile()) closeDrawer();
  });

  // Close on ESC
  document.addEventListener("keydown", (e) => {
    if (e.key === "Escape") closeDrawer();
  });

  // Auto-close when leaving mobile size
  window.addEventListener("resize", () => {
    if (!isMobile()) closeDrawer();
  });
})();
